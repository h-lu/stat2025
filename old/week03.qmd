## 第三周：描述性统计：数据探索与可视化

###  用数据讲故事：描述性统计与可视化 

前两周我们学习了统计学基本概念、R 语言入门、数据获取和数据导入。  从本周开始，我们将进入数据分析的核心环节：**描述性统计**。  描述性统计是数据分析的第一步，也是至关重要的一步。  通过描述性统计，我们可以**探索数据的基本特征、发现数据中的模式和规律、为后续的推断性统计分析奠定基础**。  本周我们将学习使用 `dplyr` 和 `tidyr` 包进行**数据清洗和预处理**的进阶操作，并学习使用强大的 `ggplot2` 包进行**数据可视化**，将数据转化为直观、易懂的图表，用数据讲故事！

**继续使用 VS Code 或 Cursor + AI 插件：**  请继续使用 VS Code 或 Cursor 编辑器，并充分利用 AI 插件的代码辅助、智能提示、聊天问答等功能，提升学习效率。

::: {.callout-note}
## 本周学习目标

*   **描述性统计核心概念:**  理解描述性统计的目的和常用方法。
*   **`dplyr` 数据清洗进阶:**  掌握 `dplyr` 包更高级的数据清洗和预处理技巧。
*   **`tidyr` 数据整理:**  学习使用 `tidyr` 包进行数据整理，转换数据结构。
*   **`ggplot2` 数据可视化入门:**  掌握 `ggplot2` 包的基本语法，绘制常用统计图表 (直方图、散点图、箱线图等)。
*   **`tidyverse` 综合应用:**  学习 `tidyverse` 生态的数据处理和可视化流程。
*   **数据探索实践:**  使用 R 和 `tidyverse` 工具，对实际数据集进行数据探索和可视化分析。
*   **AI 辅助数据分析:**  继续探索使用 AI 工具辅助数据清洗、预处理和可视化。
:::

---

### 1. 描述性统计核心概念回顾与拓展

*   **描述性统计的目的:**

    *   **概括数据特征:**  用简洁的数值或图表，描述数据集的**中心趋势** (均值、中位数、众数)、**离散程度** (标准差、方差、四分位距)、**分布形状** (偏度、峰度) 等特征。
    *   **发现数据模式:**  通过统计图表，**直观地展示数据分布、变量关系、群体差异** 等模式和规律。
    *   **数据质量评估:**  检查数据中是否存在**异常值、缺失值、错误值** 等问题，评估数据质量。
    *   **为推断性统计做准备:**  描述性统计的结果可以帮助我们**选择合适的推断性统计方法、提出研究假设**。

*   **常用描述性统计量:**

    *   **中心趋势:**
        *   **均值 (Mean):**  所有数据的平均值，对异常值敏感。  R 函数: `mean()`
        *   **中位数 (Median):**  将数据排序后，位于中间位置的值，对异常值不敏感。  R 函数: `median()`
        *   **众数 (Mode):**  数据集中出现次数最多的值。  R 中没有直接计算众数的函数，可以自定义函数或使用 `table()` 和 `sort()` 函数组合计算。
    *   **离散程度:**
        *   **标准差 (Standard Deviation):**  度量数据分散程度的常用指标，反映数据值偏离均值的平均程度。  R 函数: `sd()`
        *   **方差 (Variance):**  标准差的平方。  R 函数: `var()`
        *   **四分位距 (Interquartile Range, IQR):**  第三四分位数 (Q3) 与第一四分位数 (Q1) 之差，反映中间 50% 数据的离散程度，对异常值不敏感。  R 函数: `IQR()`
        *   **极差 (Range):**  最大值与最小值之差，对异常值非常敏感。  R 函数: `range()` (返回最小值和最大值),  `diff(range())`  计算极差。
    *   **分布形状:**
        *   **偏度 (Skewness):**  描述数据分布的对称性。  偏度 > 0  为右偏 (正偏)，偏度 < 0  为左偏 (负偏)，偏度 ≈ 0  为对称分布。  R 中 `e1071` 包的 `skewness()` 函数可以计算偏度。
        *   **峰度 (Kurtosis):**  描述数据分布的尖峭程度。  峰度 > 3  为尖峰分布，峰度 < 3  为平峰分布，峰度 ≈ 3  为正态分布 (峰度为 3)。  R 中 `e1071` 包的 `kurtosis()` 函数可以计算峰度。

*   **常用描述性统计图表:**

    *   **直方图 (Histogram):**  展示数值型变量的**分布**情况，X 轴表示数值范围，Y 轴表示频数或频率。  `ggplot2` 函数: `geom_histogram()`
    *   **箱线图 (Boxplot):**  展示数值型变量的**分布、中位数、四分位数、异常值** 等信息，方便比较不同组别的数据分布。  `ggplot2` 函数: `geom_boxplot()`
    *   **散点图 (Scatter Plot):**  展示两个数值型变量之间的**关系**，X 轴和 Y 轴分别表示两个变量，每个点代表一个观测值。  `ggplot2` 函数: `geom_point()`
    *   **条形图 (Bar Chart):**  展示**分类变量**的**频数或频率**，X 轴表示分类，Y 轴表示计数或比例。  `ggplot2` 函数: `geom_bar()` 或 `geom_col()` (当 Y 轴数据已汇总时使用 `geom_col()`)
    *   **饼图 (Pie Chart):**  展示**分类变量**的**占比**，不推荐过度使用，条形图通常更清晰。  `ggplot2`  中绘制饼图较为复杂，可以使用其他包或方法。
    *   **折线图 (Line Chart):**  展示**时间序列数据**的**趋势**，X 轴通常表示时间，Y 轴表示数值。  `ggplot2` 函数: `geom_line()`

*   **选择合适的描述性统计方法:**  根据**变量类型**和**分析目的**选择合适的描述性统计方法。

    *   **数值型变量:**  常用均值、中位数、标准差、方差、四分位距、直方图、箱线图、散点图等。
    *   **分类变量:**  常用频数、频率、百分比、条形图、饼图等。
    *   **探索变量关系:**  常用散点图、相关系数 (数值型变量之间),  分组箱线图/条形图 (分类变量与数值型变量之间),  交叉表 (分类变量之间)。
    *   **数据质量评估:**  常用缺失值统计、异常值检测 (箱线图、散点图)、描述性统计量 (检查数据范围和分布是否合理)。

### 2. `dplyr` 数据清洗和预处理进阶

*   **回顾 `dplyr` 基础:**  回顾上周学习的 `dplyr`  基础 "动词"： `filter()`, `select()`, `mutate()`, `arrange()`, `summarize()`, `group_by()`, `%>%` 管道操作符。

*   **`dplyr`  数据清洗常用技巧:**

    *   **处理缺失值:**
        *   **`filter(!is.na(列名))`:**  删除包含缺失值的行。  `!is.na()`  返回逻辑值，`TRUE`  表示非缺失值，`FALSE`  表示缺失值，`!`  表示取反。
        *   **`mutate(新列名 = ifelse(is.na(列名), 替换值, 列名))`:**  用指定值 (例如，均值、中位数、0、特定值) 替换缺失值。  `ifelse()`  函数是条件赋值函数，`ifelse(条件, 真值, 假值)`。
        *   **`tidyr::replace_na(list(列名 = 替换值))`:**  使用 `tidyr` 包的 `replace_na()` 函数替换缺失值，语法更简洁。
    *   **处理重复值:**
        *   **`distinct()`:**  删除完全重复的行。
        *   **`distinct(列名1, 列名2, ...)`:**  根据指定的列组合删除重复行，保留第一次出现的行。
        *   **`duplicated()`:**  检测重复值，返回逻辑向量，`TRUE`  表示重复值，`FALSE`  表示非重复值。  常与 `filter()`  函数结合使用，筛选或删除重复值。
    *   **处理异常值:**
        *   **箱线图可视化:**  使用箱线图识别可能的异常值 (超出箱线图 "须" 的点)。
        *   **基于标准差的方法:**  例如，将超出均值 ± 3 倍标准差范围的值视为异常值。
        *   **基于 IQR 的方法:**  例如，将小于 Q1 - 1.5 * IQR 或大于 Q3 + 1.5 * IQR 的值视为异常值 (箱线图的 "须" 的计算方法)。
        *   **根据业务知识判断:**  结合实际业务背景和数据含义，判断哪些值是合理的，哪些值可能是异常的。
        *   **处理异常值的方法:**  删除异常值、替换为缺失值、替换为合理值 (例如，均值、 Winsorize 处理)、保留异常值 (如果异常值本身包含重要信息)。
    *   **数据类型转换:**
        *   **`mutate(列名 = as.类型(列名))`:**  使用 `as.类型()` 函数转换列的数据类型。  例如，`as.character()`, `as.numeric()`, `as.integer()`, `as.logical()`, `as.factor()`, `as.Date()`, `as.POSIXct()` 等。
        *   **`readr::parse_类型(列名)`:**  使用 `readr` 包的 `parse_类型()` 函数进行类型转换，更严格和规范。  例如，`parse_character()`, `parse_double()`, `parse_integer()`, `parse_logical()`, `parse_factor()`, `parse_date()`, `parse_datetime()`, `parse_time()`, `parse_number()`, `parse_currency()`。
        *   **字符数据处理:**
            *   **`stringr` 包:**  `tidyverse`  的 `stringr` 包专门用于字符数据处理，提供了丰富的字符串操作函数，例如，字符串拼接、分割、提取、替换、大小写转换、去除空格、模式匹配 (正则表达式) 等。  常用的 `stringr` 函数包括： `str_c()`, `str_split()`, `str_sub()`, `str_replace()`, `str_to_lower()`, `str_to_upper()`, `str_trim()`, `str_detect()`, `str_extract()`, `str_match()` 等。
            *   **示例:**
                ```r
                library(dplyr)
                library(stringr)

                data <- tibble(
                  name = c("  John Doe  ", "Jane Smith", "Peter-Pan ", "Alice_Wonderland"),
                  city_state = c("New York, NY", "Los Angeles, CA", "London, UK", "Paris, FR")
                )

                cleaned_data <- data %>%
                  mutate(
                    name_trimmed = str_trim(name),  # 去除姓名两端空格
                    name_upper = str_to_upper(name_trimmed),  # 姓名转换为大写
                    first_name = str_split_fixed(name_trimmed, " ", n = 2)[, 1],  # 提取 first name
                    last_name = str_split_fixed(name_trimmed, " ", n = 2)[, 2],  # 提取 last name
                    city = str_split_fixed(city_state, ", ", n = 2)[, 1],  # 提取城市
                    state_country = str_split_fixed(city_state, ", ", n = 2)[, 2]  # 提取州/国家
                  ) %>%
                  select(-name, -city_state)  # 删除原始列

                print(cleaned_data)
                ```

*   **`dplyr`  进阶操作:**

    *   **条件型数据转换 (`case_when()`):**  `case_when()`  函数可以根据多个条件进行赋值，类似于 `if-else if-else`  结构，但语法更简洁，可读性更高。
        ```r
        data_with_category <- data %>%
          mutate(
            category = case_when(
              value < 10 ~ "Low",
              value >= 10 & value < 50 ~ "Medium",
              value >= 50 ~ "High",
              TRUE ~ "Unknown"  # 默认情况，类似于 else
            )
          )
        ```
    *   **窗口函数 (`window functions`):**  窗口函数可以在分组数据上进行计算，例如，计算每个分组内的排名、累计值、移动平均值等。  `dplyr`  提供了 `row_number()`, `rank()`, `dense_rank()`, `percent_rank()`, `lead()`, `lag()`, `cumsum()`, `cummean()`, `cummax()`, `cummin()`  等窗口函数。  窗口函数通常与 `group_by()`  和 `mutate()`  函数结合使用。
        ```r
        data_with_rank <- data %>%
          group_by(group_col) %>%
          mutate(
            rank_within_group = rank(value),  # 计算组内排名
            cumulative_sum = cumsum(value)  # 计算组内累计和
          ) %>%
          ungroup()  # 取消分组，后续操作不再分组
        ```

*   **`dplyr`  数据清洗练习:**  使用 `flights`  数据集或其他数据集，练习使用 `dplyr`  进行数据清洗和预处理，例如：
    *   处理 `flights`  数据集中的缺失值 (例如，`dep_delay`, `arr_delay`, `air_time`  等列可能存在缺失值)。
    *   检测和处理 `flights`  数据集中的异常值 (例如，`dep_delay`, `arr_delay`, `distance`  等列可能存在异常值)。
    *   将 `flights`  数据集中的航空公司代码 `carrier`  转换为航空公司名称 (可以使用 `航空公司代码-名称`  对照表，进行 join 操作，下周学习 join)。
    *   使用 `stringr`  包处理 `flights`  数据集中的字符型数据 (如果存在)。
    *   使用 `case_when()`  函数创建新的分类变量 (例如，根据 `dep_delay`  将航班分为 "准点", "轻微延误", "严重延误" 等类别)。
    *   使用窗口函数计算每个航空公司的航班数量排名、平均延误时间排名等。

### 3. `tidyr` 数据整理：数据变形

*   **`tidyr` 包的目的:**  `tidyr` 包是 `tidyverse`  生态中专门用于**数据整理 (data tidying)** 的包。  数据整理的目标是将数据转换为**整洁数据 (tidy data)** 格式，方便后续的数据分析和可视化。  **整洁数据** 的核心原则是：

    *   **每个变量占一列 (Each variable forms a column).**
    *   **每个观测值占一行 (Each observation forms a row).**
    *   **每个值自成一个单元格 (Each value forms a cell).**

*   **`tidyr`  数据变形常用函数:**

    *   **`pivot_longer()` (长数据透视):**  将**宽格式 (wide format)** 数据转换为**长格式 (long format)** 数据。  宽格式数据中，一个观测值的多个变量可能分布在多列中，长格式数据则将这些变量 "堆叠" 成一列，并使用另一列标识变量名。  `pivot_longer()`  函数可以将指定的**多列** "透视" 成**两列**：**变量名列 (name column)** 和 **值列 (value column)**。
        ```r
        # 宽格式数据示例
        wide_data <- tibble(
          id = 1:3,
          var1_2020 = c(10, 12, 15),
          var2_2020 = c(20, 25, 30),
          var1_2021 = c(11, 13, 16),
          var2_2021 = c(22, 27, 33)
        )

        # 使用 pivot_longer() 转换为长格式
        long_data <- wide_data %>%
          pivot_longer(
            cols = starts_with("var"),  # 指定要透视的列，使用 starts_with() 选择以 "var" 开头的列
            names_to = c("variable", "year"),  # 指定变量名列和年份列的名称
            names_sep = "_",  # 指定列名分隔符 "_"
            values_to = "value"  # 指定值列的名称
          )

        print(long_data)
        ```
        *   **`cols` 参数:**  指定要透视的列。  可以使用列名向量、列索引向量、列名选择函数 (例如 `starts_with()`, `ends_with()`, `contains()`, `matches()`, `num_range()`, `everything()`, `last_col()`) 等。
        *   **`names_to` 参数:**  指定透视后的变量名列的名称。  可以传入一个字符向量，指定变量名列的名称，如果 `names_sep` 或 `names_pattern` 参数被使用，则 `names_to`  可以传入多个名称，表示将列名拆分成多列。
        *   **`names_sep` 参数:**  指定列名分隔符。  如果列名包含多个信息，可以使用分隔符将列名拆分成多列。
        *   **`names_pattern` 参数:**  使用正则表达式匹配列名，并将匹配到的部分拆分成多列。  `names_sep` 和 `names_pattern`  只能使用一个。
        *   **`values_to` 参数:**  指定透视后的值列的名称。

    *   **`pivot_wider()` (宽数据透视):**  将**长格式 (long format)** 数据转换为**宽格式 (wide format)** 数据。  `pivot_wider()`  是 `pivot_longer()`  的逆操作。  `pivot_wider()`  函数需要指定**哪一列作为新的列名 (names_from)**，**哪一列作为新的值 (values_from)**。
        ```r
        # 长格式数据示例 (上例中的 long_data)
        long_data <- tibble(
          id = rep(1:3, each = 4),
          variable = rep(c("var1", "var2"), each = 2, times = 3),
          year = rep(rep(c("2020", "2021"), each = 1), times = 6),
          value = c(10, 20, 12, 25, 15, 30, 11, 22, 13, 27, 16, 33)
        )

        # 使用 pivot_wider() 转换为宽格式
        wide_data_reconstructed <- long_data %>%
          pivot_wider(
            names_from = c("variable", "year"),  # 指定列名来源列，这里使用 variable 和 year 两列组合作为新列名
            values_from = "value"  # 指定值来源列
          )

        print(wide_data_reconstructed)
        ```
        *   **`names_from` 参数:**  指定列名来源列。  可以使用列名向量，指定一列或多列作为新列名的来源。  如果指定多列，则新列名将由这些列的值组合而成。
        *   **`values_from` 参数:**  指定值来源列。  可以使用列名向量，指定一列或多列作为新值的来源。  如果 `names_from`  指定了多列，`values_from`  也应该指定相同数量的列，或者只指定一列，表示所有新列的值都来自同一列。

    *   **`separate()` (列分割):**  将**一列**按照指定的分隔符分割成**多列**。  `separate()`  函数类似于 `stringr::str_split_fixed()`  函数，但 `separate()`  直接操作数据框列，更方便。
        ```r
        data_with_combined_col <- tibble(
          combined_col = c("A-1", "B-2", "C-3")
        )

        separated_data <- data_with_combined_col %>%
          separate(
            col = combined_col,  # 指定要分割的列
            into = c("col1", "col2"),  # 指定分割后的新列名
            sep = "-"  # 指定分隔符 "-"
          )

        print(separated_data)
        ```
        *   **`col` 参数:**  指定要分割的列名。
        *   **`into` 参数:**  指定分割后的新列名。  传入一个字符向量，指定新列的名称。
        *   **`sep` 参数:**  指定分隔符。  可以使用字符或正则表达式作为分隔符。

    *   **`unite()` (列合并):**  将**多列**合并成**一列**，并使用指定的分隔符连接。  `unite()`  是 `separate()`  的逆操作。
        ```r
        separated_data <- tibble(
          col1 = c("A", "B", "C"),
          col2 = c("1", "2", "3")
        )

        united_data <- separated_data %>%
          unite(
            col = combined_col,  # 指定合并后的新列名
            col1, col2,  # 指定要合并的列
            sep = "-"  # 指定分隔符 "-"
          )

        print(united_data)
        ```
        *   **`col` 参数:**  指定合并后的新列名。
        *   **`...` 参数:**  使用 `...`  传入要合并的列名，可以传入多个列名。
        *   **`sep` 参数:**  指定分隔符。

*   **`tidyr`  数据整理练习:**  使用 `flights`  数据集或其他数据集，练习使用 `tidyr`  进行数据整理，例如：
    *   将 `flights`  数据集转换为长格式，例如，将 `dep_delay` 和 `arr_delay`  两列透视为一列 `delay_type` (取值为 "dep_delay" 或 "arr_delay") 和一列 `delay_time` (延误时间)。
    *   将宽格式的数据 (例如，包含多年份数据的表格) 转换为长格式，方便进行时间序列分析或面板数据分析。
    *   分割包含复合信息的列，例如，将日期时间列分割成日期列和时间列，将地址列分割成城市列、州列、国家列等。
    *   合并多列信息，例如，将年、月、日列合并成日期列，将姓、名列合并成姓名列。

### 4. `ggplot2` 数据可视化初步：常用图表

*   **`ggplot2` 包简介:**  `ggplot2` 包是 R 语言中最强大、最灵活、最流行的**数据可视化**包，也是 `tidyverse`  生态的核心包之一。  `ggplot2`  基于**图层语法 (grammar of graphics)**，将数据可视化分解为多个独立的图层，用户可以灵活组合这些图层，创建各种复杂的统计图表。  `ggplot2`  的特点包括：

    *   **图层语法:**  基于图层语法，灵活、强大、可扩展。
    *   **美观的默认样式:**  默认生成的图表美观、专业。
    *   **高度定制化:**  可以高度定制图表的各个方面，例如，颜色、形状、大小、标签、标题、主题等。
    *   **与 `tidyverse`  完美集成:**  与 `dplyr`, `tidyr`  等 `tidyverse`  包无缝衔接，数据处理和可视化流程流畅。

*   **`ggplot2`  基本语法:**  `ggplot2`  绘图的基本流程是：

    1.  **创建 `ggplot` 对象:**  使用 `ggplot()` 函数创建 `ggplot` 对象，并指定**数据 (data)** 和**映射 (mapping, `aes()`)**。  `data` 参数指定要使用的数据框，`mapping` 参数使用 `aes()` 函数指定**变量**如何**映射**到**图形属性 (aesthetics)**，例如，X 轴、Y 轴、颜色、形状、大小、填充等。
    2.  **添加几何对象 (geometric objects, `geom_xxx()`):**  使用各种 `geom_xxx()` 函数添加**几何对象**图层，例如，`geom_point()` (散点图), `geom_line()` (折线图), `geom_bar()` (条形图), `geom_histogram()` (直方图), `geom_boxplot()` (箱线图) 等。  每个 `geom_xxx()` 函数都对应一种图表类型。  几何对象图层决定了图表的**类型**和**基本形状**。
    3.  **添加统计变换 (statistical transformations, `stat_xxx()`):**  某些几何对象需要进行**统计变换**，例如，直方图需要计算频数，条形图需要计算汇总统计量。  `ggplot2`  会自动进行默认的统计变换，用户也可以使用 `stat_xxx()` 函数手动指定统计变换。  通常情况下，无需手动添加统计变换图层。
    4.  **添加标度 (scales, `scale_xxx_yyy()`):**  标度控制**数据值**到**图形属性**的**映射方式**，例如，X 轴和 Y 轴的刻度范围、颜色标度、形状标度、大小标度等。  `ggplot2`  会自动使用默认标度，用户可以使用 `scale_xxx_yyy()` 函数自定义标度，例如，`scale_x_continuous()`, `scale_y_continuous()`, `scale_color_manual()`, `scale_shape_manual()`, `scale_size_continuous()` 等。
    5.  **添加坐标系 (coordinate systems, `coord_xxx()`):**  坐标系控制图表的**坐标轴类型**和**方向**，例如，笛卡尔坐标系 (默认), 极坐标系, 地理坐标系等。  `ggplot2`  默认使用笛卡尔坐标系，用户可以使用 `coord_xxx()` 函数自定义坐标系，例如，`coord_cartesian()`, `coord_polar()`, `coord_map()` 等。
    6.  **添加分面 (faceting, `facet_xxx()`):**  分面可以将图表**分割成多个子图**，按照一个或多个分类变量进行分组，方便比较不同组别的数据。  `ggplot2`  提供了 `facet_wrap()` (单变量分面) 和 `facet_grid()` (双变量分面) 函数。
    7.  **添加主题 (themes, `theme()`):**  主题控制图表的**整体外观样式**，例如，背景颜色、网格线、字体、标题位置、图例样式等。  `ggplot2`  提供了多种内置主题 (例如 `theme_bw()`, `theme_minimal()`, `theme_classic()`)，用户也可以使用 `theme()` 函数自定义主题。
    8.  **添加标签、标题等 (labels, titles, etc., `labs()`, `ggtitle()`, `xlab()`, `ylab()`, `caption()`):**  使用 `labs()` 函数添加**标签** (例如，X 轴标签、Y 轴标签、颜色图例标签、形状图例标签等),  使用 `ggtitle()` 函数添加**主标题**,  使用 `xlab()` 和 `ylab()` 函数分别添加 X 轴和 Y 轴标签,  使用 `caption()` 函数添加**图表脚注**。

*   **常用 `ggplot2`  图表类型示例 (使用 `flights`  数据集):**

    *   **直方图 (Histogram):**  展示 `dep_delay`  出发延误时间的分布。
        ```r
        library(ggplot2)

        ggplot(flights, aes(x = dep_delay)) +
          geom_histogram(binwidth = 15)  # binwidth 参数指定组距
        ```
        *   `ggplot(flights, aes(x = dep_delay))`:  创建 `ggplot` 对象，指定数据为 `flights` 数据框，X 轴映射为 `dep_delay` 变量。
        *   `geom_histogram(binwidth = 15)`:  添加直方图几何对象图层，`binwidth = 15`  指定组距为 15 分钟。

    *   **散点图 (Scatter Plot):**  展示 `dep_delay`  出发延误时间与 `arr_delay`  到达延误时间的关系。
        ```r
        ggplot(flights, aes(x = dep_delay, y = arr_delay)) +
          geom_point()
        ```
        *   `ggplot(flights, aes(x = dep_delay, y = arr_delay))`:  创建 `ggplot` 对象，指定 X 轴映射为 `dep_delay`，Y 轴映射为 `arr_delay`。
        *   `geom_point()`:  添加散点图几何对象图层。

    *   **箱线图 (Boxplot):**  比较不同航空公司 `carrier`  的 `arr_delay`  到达延误时间分布。
        ```r
        ggplot(flights, aes(x = carrier, y = arr_delay)) +
          geom_boxplot()
        ```
        *   `ggplot(flights, aes(x = carrier, y = arr_delay))`:  创建 `ggplot` 对象，指定 X 轴映射为 `carrier` (分类变量), Y 轴映射为 `arr_delay` (数值型变量)。
        *   `geom_boxplot()`:  添加箱线图几何对象图层。

    *   **条形图 (Bar Chart):**  展示不同航空公司 `carrier`  的航班数量。
        ```r
        ggplot(flights, aes(x = carrier)) +
          geom_bar()
        ```
        *   `ggplot(flights, aes(x = carrier))`:  创建 `ggplot` 对象，只指定 X 轴映射为 `carrier`。  `geom_bar()`  默认统计每个分类的频数。
        *   `geom_bar()`:  添加条形图几何对象图层。

    *   **添加颜色、形状、大小等图形属性:**  可以使用 `aes()` 函数在 `geom_xxx()` 函数内部或 `ggplot()` 函数内部指定额外的图形属性映射，例如，使用 `color` 映射颜色,  `shape` 映射形状,  `size` 映射大小,  `fill` 映射填充颜色等。
        ```r
        # 散点图，使用 color 映射航空公司 carrier
        ggplot(flights, aes(x = dep_delay, y = arr_delay, color = carrier)) +
          geom_point()

        # 散点图，使用 size 映射飞行距离 distance
        ggplot(flights, aes(x = dep_delay, y = arr_delay, size = distance)) +
          geom_point()
        ```

    *   **添加标题、标签、主题:**
        ```r
        ggplot(flights, aes(x = dep_delay, y = arr_delay, color = carrier)) +
          geom_point() +
          labs(title = "出发延误 vs 到达延误",  # 主标题
               subtitle = "按航空公司着色",  # 副标题
               x = "出发延误时间 (分钟)",  # X 轴标签
               y = "到达延误时间 (分钟)",  # Y 轴标签
               color = "航空公司",  # 颜色图例标签
               caption = "数据来源：nycflights13 包") +  # 图表脚注
          theme_bw()  # 使用黑白主题
        ```

*   **`ggplot2`  可视化练习:**  使用 `flights`  数据集或其他数据集，练习使用 `ggplot2`  绘制各种常用统计图表，并尝试自定义图表的各个方面，例如：
    *   绘制 `flights`  数据集 `distance`  飞行距离的直方图，并尝试调整 `binwidth`  参数。
    *   绘制 `flights`  数据集 `air_time`  飞行时间的箱线图，按照出发机场 `origin`  分组。
    *   绘制 `flights`  数据集 `dep_delay`  与 `arr_delay`  的散点图，并使用颜色或形状映射航空公司 `carrier`。
    *   绘制 `flights`  数据集航空公司 `carrier`  的条形图，并添加航班数量标签。
    *   尝试修改图表的标题、标签、颜色、主题等，使图表更美观、更易读。

### 5. `tidyverse` 生态综合应用：数据处理与可视化流程

*   **`tidyverse`  数据分析流程:**  `tidyverse`  生态提供了一套完整的数据分析流程，包括：

    1.  **数据导入 (`readr`, `datatable`):**  使用 `readr` 或 `datatable` 包读取各种数据格式的文件。
    2.  **数据整理 (`tidyr`):**  使用 `tidyr` 包将数据转换为整洁数据格式。
    3.  **数据清洗和预处理 (`dplyr`, `stringr`):**  使用 `dplyr` 和 `stringr` 包进行数据清洗、缺失值处理、异常值处理、数据类型转换、字符数据处理等。
    4.  **数据探索和描述性统计 (`dplyr`):**  使用 `dplyr` 包进行数据汇总、分组统计、计算描述性统计量。
    5.  **数据可视化 (`ggplot2`):**  使用 `ggplot2` 包绘制各种统计图表，探索数据模式、展示分析结果。
    6.  **数据建模和推断性统计 (后续课程):**  使用 R 的统计建模和推断性统计功能进行更深入的数据分析 (本周不涉及)。
    7.  **结果沟通和报告 (后续课程):**  将数据分析结果整理成报告、幻灯片、交互式应用等形式，进行有效沟通 (本周不涉及)。

*   **`tidyverse`  流程示例 (使用 `flights`  数据集):**  以分析不同航空公司的平均延误时间为例，演示 `tidyverse`  数据处理和可视化流程。

    ```r
    library(tidyverse)
    library(nycflights13)

    # 1. 数据导入 (flights 数据集已加载到 nycflights13 包中，无需额外导入)

    # 2. 数据整理 (flights 数据集已经是整洁数据格式，无需整理)

    # 3. 数据清洗和预处理 (简单处理缺失值，移除到达延误时间为缺失值的航班)
    flights_cleaned <- flights %>%
      filter(!is.na(arr_delay))

    # 4. 数据探索和描述性统计 (按照航空公司分组，计算平均到达延误时间)
    carrier_delay_summary <- flights_cleaned %>%
      group_by(carrier) %>%
      summarize(mean_delay = mean(arr_delay)) %>%
      arrange(desc(mean_delay))  # 按照平均延误时间降序排序

    print(carrier_delay_summary)

    # 5. 数据可视化 (绘制条形图，展示不同航空公司的平均到达延误时间)
    ggplot(carrier_delay_summary, aes(x = carrier, y = mean_delay)) +
      geom_col(fill = "steelblue") +  # 柱形图，填充颜色为 steelblue
      geom_text(aes(label = round(mean_delay, 1)),  # 添加文本标签，显示平均延误时间，保留一位小数
                vjust = -0.5) +  # 标签垂直位置微调
      labs(title = "不同航空公司平均到达延误时间",
           x = "航空公司代码",
           y = "平均到达延误时间 (分钟)") +
      theme_minimal()  # 使用 minimal 主题
    ```

*   **`tidyverse`  综合练习:**  选择一个实际数据集 (例如，`flights`  数据集、项目一的数据集或其他公开数据集)，使用 `tidyverse`  生态的 `readr`, `tidyr`, `dplyr`, `stringr`, `ggplot2`  包，完成一个完整的数据分析和可视化项目，包括数据导入、数据整理、数据清洗、数据预处理、描述性统计分析、数据可视化、结果解释和报告撰写 (报告撰写为可选，重点练习数据处理和可视化)。

### 6. 本周内容总结与下周预告

*   **本周回顾:**  回顾本周学习内容，巩固重点知识。  本周我们**深入学习**了描述性统计的核心概念，`dplyr`  数据清洗和预处理进阶技巧，`tidyr`  数据整理方法，`ggplot2`  数据可视化初步，以及 `tidyverse`  生态的综合应用。  **描述性统计、数据清洗、数据整理和数据可视化是数据分析的关键技能，务必熟练掌握本周所学内容。**

*   **下周预告:**  下周我们将继续深入学习 `ggplot2` 包，学习更高级的数据可视化技巧，例如，多图层组合、图形精细调整、交互式图表制作等。  我们将探索更多 `ggplot2`  的几何对象、统计变换、标度、坐标系、分面、主题等，打造更专业、更精美、更具洞察力的数据可视化作品。

### 7. 课后任务

*   **小组任务:**
    *   **项目一数据清洗和预处理:**  各小组根据本周学习的数据清洗和预处理方法，使用 `dplyr` 和 `tidyr` 包对项目一的数据集进行数据清洗和预处理。  完成缺失值处理、异常值处理、数据类型转换、数据整理等任务，确保数据质量和整洁性，为后续的数据分析和可视化做好准备。
    *   **项目一数据可视化方案:**  小组讨论项目一的数据可视化方案，确定要展示的数据特征和模式，选择合适的图表类型，设计图表布局和样式。

*   **个人任务:**
    *   **复习本周内容:**  回顾本周讲义和课堂笔记，巩固描述性统计概念、`dplyr`  数据清洗技巧、`tidyr`  数据整理方法、`ggplot2`  可视化语法和常用图表类型。
    *   **R 代码练习:**  完成本讲义中布置的 R 代码练习，熟练掌握 `dplyr`, `tidyr`, `stringr`, `ggplot2`  包的常用函数。  尝试使用 AI 插件辅助 R 代码练习。
    *   **数据集可视化探索:**  选择 `flights`  数据集或项目一的数据集，使用 `ggplot2`  包进行数据可视化探索，尝试绘制各种图表，并自定义图表样式，深入理解数据特征和模式。  可以尝试完成讲义中提供的练习题，也可以自己设计可视化探索任务。

::: {.callout-tip}
## AI 辅助学习小贴士

*   **R 代码练习:**  继续在 VS Code 或 Cursor 中练习 R 语言代码，充分利用 AI 插件的代码自动补全、代码生成、代码解释、AI 聊天等功能。  遇到 R 代码问题，及时向 AI 提问。
*   **数据包使用问题:**  如果在使用 `dplyr`, `tidyr`, `stringr`, `ggplot2`  等数据包时遇到问题，可以查阅包的官方文档，或者使用 AI 聊天提问，寻求帮助。
    *   **`dplyr`  数据清洗技巧:**  例如，如何使用 `filter()`  筛选满足多个条件的行？  如何使用 `mutate()`  创建多个新列？  如何使用 `group_by()`  和 `summarize()`  进行分组汇总统计？
    *   **`tidyr`  数据整理方法:**  例如，`pivot_longer()`  和 `pivot_wider()`  函数的参数如何设置？  `separate()`  和 `unite()`  函数如何使用？  如何将复杂格式的数据转换为整洁数据？
    *   **`ggplot2`  可视化语法:**  例如，`ggplot()`  和 `aes()`  函数如何使用？  各种 `geom_xxx()`  函数的作用是什么？  如何添加标题、标签、主题？  如何自定义图表样式？
*   **统计图表选择:**  如果不确定使用哪种图表类型来展示数据，可以通过AI聊天工具寻求建议。例如，可以提问："哪种图表适合比较多个组的分布情况？" 或 "如何可视化两个数值变量之间的关系？"。AI不仅会推荐合适的图表类型，还会提供相应的`ggplot2`代码示例。
*   **可视化代码生成:**  使用 AI 代码生成功能，输入注释，例如：  `# 使用 ggplot2 创建价格的直方图`,  `# 使用 ggplot2 创建 'x' 和 'y' 的散点图，并按 'category' 着色`,  让 AI 生成可视化代码。
*   **代码解释和优化:**  使用 AI 代码解释功能，选中 `tidyverse`  代码片段，让 AI 解释代码的功能和每一行代码的作用。  如果代码运行效率较低，可以使用 AI 聊天咨询代码优化技巧。
:::

::: {.callout-note}
## 学习寄语

**图表胜千言！  本周我们学习了描述性统计和数据可视化的核心技能，掌握了用数据讲故事的能力。  精美、清晰、有洞察力的图表是数据分析的灵魂！**  继续保持学习的热情，充分利用 VS Code/Cursor 和 AI 插件的强大功能，相信大家会在统计学和 R 语言的学习中取得更大的进步！  下周见！
::: 