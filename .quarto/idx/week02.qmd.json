{"title":"第二周：R语言数据导入与常用数据包","markdown":{"headingText":"第二周：R语言数据导入与常用数据包","containsRefs":false,"markdown":"\n### 掌握R语言数据读取利器\n\n上周我们学习了数据获取的基本方法。本周，我们将深入学习**R语言数据导入**，掌握使用 R 读取各种数据格式的技能。我们将重点介绍 `tidyverse` 生态中的 `readr` 包和高性能的 `datatable` 包，并学习 R 中的基本数据类型、常用统计函数以及 `dplyr` 包的基础用法，为后续的数据分析打下更坚实的基础。\n\n**继续使用 VS Code 或 Cursor + AI 插件：**  请继续使用 VS Code 或 Cursor 编辑器，并充分利用 AI 插件的代码辅助、智能提示、聊天问答等功能，提升学习效率。\n\n::: {.callout-note}\n## 本周学习目标\n\n*   **R 数据导入进阶:**  掌握 `readr` 和 `datatable` 包导入各种数据格式。\n*   **数据包对比:**  了解 `readr` 和 `datatable` 的特点和适用场景。\n*   **R 数据类型:**  熟悉 R 中的基本数据类型。\n*   **常用统计函数:**  掌握 R 中常用的统计函数。\n*   **`dplyr` 基础:**  初步掌握 `dplyr` 包的基本数据操作。\n*   **实战演练:**  使用 `flights` 数据集进行数据导入和导出练习。\n*   **AI 辅助数据操作:**  继续探索使用 AI 工具辅助 R 数据操作。\n:::\n\n---\n\n### 1. R 语言数据导入常用包：`readr` vs `datatable`\n\n*   **`tidyverse`  `readr` 包 (回顾与进阶):**\n\n    *   **快速便捷:**  `readr` 包是 `tidyverse` 核心包之一，专注于快速、方便地读取各种表格数据文件 (CSV, TXT, TSV 等)。\n    *   **自动类型推断:**  `readr` 能够自动检测列的数据类型，并进行合理的转换。\n    *   **灵活的参数设置:**  `readr` 提供了丰富的参数，可以灵活控制数据导入过程，例如，指定列名、跳过行、限制读取行数、自定义分隔符、处理缺失值、指定列类型、处理编码问题等。\n    *   **返回 `tibble` 数据框:**  `readr` 读取的数据默认是 `tibble` 格式，是 `tidyverse` 推荐使用的数据框，打印输出更友好，子集操作更严谨。\n    *   **常用函数:**\n        *   `read_csv()`: 读取逗号分隔的 CSV 文件。\n        *   `read_tsv()`: 读取制表符分隔的 TSV 文件。\n        *   `read_delim()`: 读取更广泛的分隔符文件，可以自定义分隔符。\n        *   `read_fwf()`: 读取固定宽度的文件。\n        *   `read_table()`: 读取空格分隔的表格文件。\n    *   **进阶用法:**  上周我们已经学习了 `read_csv()` 和 `read_tsv()` 的基本用法。  本周我们进一步学习 `readr` 的进阶用法，例如：\n        *   **`col_names` 参数:**  用于指定列名。  可以传入字符向量作为列名，或者 `col_names = FALSE` 表示数据文件的第一行不是列名。\n        *   **`skip` 参数:**  用于跳过文件开头的若干行。  例如，`skip = 1` 跳过第一行。\n        *   **`n_max` 参数:**  用于限制最多读取的行数。  例如，`n_max = 100`  只读取前 100 行。\n        *   **`col_types` 参数:**  用于手动指定每一列的数据类型。  例如，`col_types = cols(col1 = col_character(), col2 = col_double())`  指定 `col1` 为字符型，`col2` 为数值型。  常用的类型包括 `col_character()`, `col_double()`, `col_integer()`, `col_logical()`, `col_factor()`, `col_date()`, `col_datetime()`, `col_time()`, `col_number()`, `col_currency()`, `col_skip()`, `col_guess()`.\n        *   **`locale` 参数:**  用于处理不同地区的文化和语言习惯，例如，日期和时间格式、小数点和千位分隔符、字符编码等。  可以使用 `locale()` 函数创建 locale 对象，并传入 `locale` 参数。  例如，`locale = locale(encoding = \"GBK\")`  指定使用 GBK 编码。\n\n*   **`datatable` 包 (高性能数据读取):**\n\n    *   **快速高效:**  `datatable` 包是一个高性能的数据处理包，其数据读取速度非常快，尤其是在处理大型数据文件时，速度远超 `readr` 和 R 基础函数。  `datatable` 包使用 C 语言编写，底层优化，效率极高。\n    *   **`fread()` 函数:**  `datatable` 包最核心的函数是 `fread()`，用于快速读取各种格式的表格数据文件 (包括 CSV, TXT 等)。  `fread()`  功能强大，参数丰富，可以灵活控制数据导入过程。\n    *   **自动类型推断 (更智能):**  `fread()`  的自动类型推断功能比 `readr` 更智能，能够更准确地识别列的数据类型，并进行高效的转换。\n    *   **多线程读取:**  `fread()`  支持多线程读取，可以充分利用多核 CPU 的性能，进一步提高读取速度 (默认使用所有可用 CPU 核心)。\n    *   **语法简洁:**  `fread()`  的语法简洁易用，很多参数都有默认值，通常只需指定文件路径即可快速读取数据。\n    *   **返回 `data.table` 数据框:**  `fread()`  读取的数据是 `data.table` 格式。  `data.table` 是 `datatable` 包定义的一种高性能数据框，在数据处理和分析方面具有很多优势，例如，速度更快、语法更简洁、功能更强大。  `data.table`  的语法和操作方式与 R 基础的 `data.frame`  和 `tidyverse` 的 `tibble`  有所不同，需要学习其特有的语法。  **本课程中，我们主要使用 `tibble` 数据框进行数据分析，`data.table`  作为扩展学习内容，感兴趣的同学可以深入学习。**\n    *   **基本用法:**\n        ```r\n        # 安装和加载 datatable 包 (如果已安装，则只需加载)\n        # install.packages(\"data.table\")\n        library(data.table)\n\n        # 使用 fread() 读取 CSV 文件\n        data_dt <- fread(\"your_data.csv\")\n\n        # 打印数据框\n        print(data_dt)\n        ```\n    *   **常用参数:**  `fread()`  函数有很多参数，常用的参数包括：\n        *   `file`:  文件路径。\n        *   `sep`:  分隔符。  默认自动检测，通常无需手动指定。\n        *   `header`:  逻辑值，是否将第一行作为列名。  默认为 `TRUE`。\n        *   `col.names`:  用于指定列名。\n        *   `skip`:  用于跳过文件开头的若干行。\n        *   `nrows`:  用于限制最多读取的行数。\n        *   `colClasses`:  用于手动指定每一列的数据类型。  例如，`colClasses = c(\"character\", \"numeric\")`  指定第一列为字符型，第二列为数值型。\n        *   `encoding`:  字符编码。  例如，`encoding = \"GBK\"`  指定使用 GBK 编码。\n\n*   **`readr` vs `datatable` 总结:**\n\n    | 特性         | `readr` (`tidyverse`) | `datatable` (`fread()`) |\n    |--------------|-----------------------|--------------------------|\n    | **速度**     | 较快                  | **非常快**               |\n    | **易用性**   | 非常易用              | 易用                     |\n    | **功能**     | 功能丰富              | 功能强大                 |\n    | **类型推断** | 自动                  | **更智能自动**           |\n    | **数据框**   | `tibble`              | `data.table`             |\n    | **依赖**     | `tidyverse`           | `datatable`              |\n    | **适用场景** | 常用数据导入          | **大型数据文件导入**     |\n\n    *   **选择建议:**\n        *   **对于一般的数据导入任务，`readr` 包已经足够快速和方便，是首选。**  `readr`  易用性好，与 `tidyverse` 生态系统兼容性好，是数据分析的常用工具。\n        *   **当需要处理非常大的数据文件，或者对数据读取速度有极高要求时，可以考虑使用 `datatable` 包的 `fread()` 函数。**  `fread()`  速度极快，性能卓越，是处理大数据的不二之选。  但需要注意 `fread()`  返回的是 `data.table` 数据框，其语法和操作方式与 `tibble`  有所不同。\n\n### 2. 使用 `flights` 数据集演示数据导入导出\n\n*   **`flights` 数据集介绍:**  `nycflights13` 包中包含了 2013 年纽约出发的所有航班数据，是一个非常经典的数据分析和演示数据集。  `tidyverse`  的很多教程和示例都使用 `flights` 数据集。\n\n    *   **加载 `nycflights13` 包:**\n        ```r\n        # 安装和加载 nycflights13 包 (如果已安装，则只需加载)\n        # install.packages(\"nycflights13\")\n        library(nycflights13)\n\n        # 查看 flights 数据集\n        head(flights)\n        ```\n    *   **`flights` 数据框:**  `flights`  是一个 `tibble` 数据框，包含了航班的各种信息，例如，出发时间、到达时间、航空公司、航班号、出发机场、到达机场、飞行距离、飞行时长等。  可以使用 `?flights`  查看数据集的详细信息。\n\n*   **保存 `flights` 数据为 CSV 文件:**\n\n    *   **使用 `readr`  `write_csv()` 函数:**  `readr` 包提供了 `write_csv()` 函数，用于将数据框保存为 CSV 文件。\n        ```r\n        # 使用 write_csv() 保存 flights 数据为 CSV 文件\n        write_csv(flights, \"flights.csv\")\n\n        # 提示：CSV 文件已保存到当前工作目录下\n        ```\n        *   **`write_csv()`  函数:**  第一个参数是要保存的数据框，第二个参数是 CSV 文件名 (带引号)。  默认使用逗号作为分隔符，UTF-8 编码，第一行写入列名。\n        *   **当前工作目录:**  CSV 文件默认保存到 R 的当前工作目录下。  可以使用 `getwd()`  函数查看当前工作目录，使用 `setwd(\"your_path\")`  设置工作目录。  建议将数据文件保存在项目文件夹下的 `data`  子文件夹中，方便管理。\n\n*   **使用 `readr`  `read_csv()` 函数读取 CSV 文件:**\n\n    *   **从 CSV 文件读取数据:**  使用 `read_csv()`  函数读取刚刚保存的 `flights.csv` 文件。\n        ```r\n        # 使用 read_csv() 读取 CSV 文件\n        flights_readr <- read_csv(\"flights.csv\")\n\n        # 打印读取的数据\n        print(flights_readr)\n\n        # 检查数据是否与原始 flights 数据集一致\n        identical(flights, flights_readr)\n        ```\n        *   **`identical()` 函数:**  用于比较两个 R 对象是否完全相同 (包括数据和属性)。  如果返回 `TRUE`，则表示两个对象完全一致。\n\n*   **使用 `datatable`  `fwrite()` 和 `fread()` 函数进行数据导入导出:**\n\n    *   **`fwrite()` 函数:**  `datatable` 包提供了 `fwrite()` 函数，用于快速将 `data.table` 或 `data.frame` 保存为文件 (包括 CSV, TXT 等)。  `fwrite()`  速度非常快，性能优异。\n        ```r\n        # 将 flights 数据转换为 data.table 格式\n        flights_dt <- as.data.table(flights)\n\n        # 使用 fwrite() 保存 data.table 为 CSV 文件\n        fwrite(flights_dt, \"flights_dt.csv\")\n\n        # 提示：CSV 文件已保存到当前工作目录下\n        ```\n        *   **`as.data.table()` 函数:**  用于将其他格式的数据框 (例如 `tibble`, `data.frame`) 转换为 `data.table` 格式。  如果数据已经是 `data.table` 格式，则无需转换。\n        *   **`fwrite()` 函数:**  第一个参数是要保存的 `data.table`，第二个参数是文件名。  默认使用逗号分隔符，UTF-8 编码，第一行写入列名。\n\n    *   **`fread()` 函数:**  使用 `fread()` 函数读取 `fwrite()`  保存的 `flights_dt.csv` 文件。\n        ```r\n        # 使用 fread() 读取 CSV 文件\n        flights_fread <- fread(\"flights_dt.csv\")\n\n        # 打印读取的数据\n        print(flights_fread)\n\n        # 检查数据是否与原始 flights_dt 数据集一致\n        identical(flights_dt, flights_fread)\n        ```\n\n*   **数据导入导出练习:**  鼓励学生尝试使用 `readr` 和 `datatable` 包的不同函数和参数，进行数据导入导出练习，例如：\n    *   使用 `write_tsv()` 和 `read_tsv()`  保存和读取 TSV 文件。\n    *   使用 `write.table()` 和 `read.table()` (R 基础函数)  进行数据导入导出，并比较速度和用法。\n    *   尝试使用 `col_names`, `skip`, `n_max`, `col_types`, `encoding` 等参数，控制数据导入过程。\n\n### 3. R 语言基本数据类型\n\n*   **R 的数据类型:**  R 语言是一种动态类型语言，变量的类型不需要显式声明，R 会自动根据赋值内容判断变量类型。  R 中常用的基本数据类型包括：\n\n    *   **数值型 (numeric):**  用于表示数值数据，包括整数和小数。  例如，`10`, `3.14`, `-5.2`。  数值型是 R 中最常用的数据类型。\n    *   **字符型 (character):**  用于表示文本数据，用引号 (单引号或双引号) 包围。  例如， `\"hello\"`,  `'world'`,  `\"统计学\"`,  `'R 语言'`。\n    *   **逻辑型 (logical):**  用于表示逻辑值，只有两个取值：`TRUE` (真) 和 `FALSE` (假)。  逻辑值常用于条件判断和逻辑运算。  例如， `TRUE`,  `FALSE`,  `10 > 5` (结果为 `TRUE`),  `\"a\" == \"b\"` (结果为 `FALSE`)。\n    *   **因子型 (factor):**  用于表示分类数据或名义变量。  因子型变量的值是有限的、预定义的类别 (levels)。  因子型变量在统计分析中非常重要，例如，用于表示性别、学历、地区、产品类别等。  使用 `factor()` 函数创建因子型变量。\n    *   **日期型 (date):**  用于表示日期数据，例如，`2023-10-26`。  R 提供了 `Date` 类型来处理日期数据。  可以使用 `as.Date()` 函数将字符型数据转换为日期型数据。\n    *   **日期时间型 (POSIXct/POSIXlt):**  用于表示日期和时间数据，例如，`2023-10-26 10:30:00`。  R 提供了 `POSIXct` 和 `POSIXlt` 两种类型来处理日期时间数据。  可以使用 `as.POSIXct()` 或 `as.POSIXlt()` 函数将字符型数据转换为日期时间型数据。\n\n*   **数据类型判断和转换:**\n\n    *   **类型判断函数:**  R 提供了多种函数用于判断变量的数据类型，例如：\n        *   `is.numeric()`:  判断是否为数值型。\n        *   `is.character()`:  判断是否为字符型。\n        *   `is.logical()`:  判断是否为逻辑型。\n        *   `is.factor()`:  判断是否为因子型。\n        *   `is.Date()`:  判断是否为日期型。\n        *   `is.POSIXct()` / `is.POSIXlt()`:  判断是否为日期时间型。\n        *   `class()`:  返回变量的类型名称 (更通用)。\n        *   `typeof()`:  返回变量的底层存储类型 (更底层)。\n\n    *   **类型转换函数:**  R 提供了多种函数用于将变量从一种类型转换为另一种类型，例如：\n        *   `as.numeric()`:  转换为数值型。\n        *   `as.character()`:  转换为字符型。\n        *   `as.logical()`:  转换为逻辑型。\n        *   `as.factor()`:  转换为因子型。\n        *   `as.Date()`:  转换为日期型。\n        *   `as.POSIXct()` / `as.POSIXlt()`:  转换为日期时间型。\n\n    *   **类型转换注意事项:**  类型转换并非总是成功，需要注意数据本身的特点和转换规则。  例如，将字符型转换为数值型时，如果字符型数据不是有效的数值格式，则会转换为 `NA` (缺失值)。  将数值型转换为逻辑型时，非零数值会转换为 `TRUE`，零值会转换为 `FALSE`。\n\n*   **数据类型练习:**  鼓励学生创建不同类型的变量，并使用类型判断和转换函数进行练习，例如：\n    ```r\n    # 数值型\n    x <- 10\n    is.numeric(x)  # TRUE\n    as.character(x) # \"10\"\n\n    # 字符型\n    y <- \"hello\"\n    is.character(y) # TRUE\n    as.numeric(y)  # NA (无法转换为数值)\n\n    # 逻辑型\n    z <- TRUE\n    is.logical(z)  # TRUE\n    as.numeric(z)  # 1 (TRUE 转换为 1)\n    as.numeric(FALSE) # 0 (FALSE 转换为 0)\n\n    # 因子型\n    gender <- factor(c(\"Male\", \"Female\", \"Male\", \"Male\", \"Female\"))\n    is.factor(gender) # TRUE\n    levels(gender)   # 查看因子水平\n\n    # 日期型\n    date_str <- \"2023-10-26\"\n    date_obj <- as.Date(date_str)\n    is.Date(date_obj) # TRUE\n    ```\n\n### 4. R 语言常用统计函数\n\n*   **描述性统计函数:**  R 提供了丰富的函数用于计算描述性统计量，常用的函数包括：\n\n    *   **中心趋势度量:**\n        *   `mean()`:  均值 (平均值)。\n        *   `median()`:  中位数 (将数据排序后位于中间位置的值)。\n        *   `modeest::mlv()`:  众数 (数据中出现频率最高的值)。  需要安装 `modeest` 包。\n    *   **离散程度度量:**\n        *   `sd()`:  标准差 (度量数据的离散程度)。\n        *   `var()`:  方差 (标准差的平方)。\n        *   `IQR()`:  四分位距 (第三四分位数减去第一四分位数)。\n        *   `range()`:  极差 (最大值减去最小值)。\n    *   **位置度量:**\n        *   `quantile()`:  分位数 (计算指定的分位数，例如，四分位数、十分位数、百分位数)。\n        *   `min()`:  最小值。\n        *   `max()`:  最大值。\n    *   **求和与计数:**\n        *   `sum()`:  求和。\n        *   `length()`:  长度 (向量或列表的元素个数)。\n        *   `count()` (dplyr):  计数 (统计数据框中不同值的频数)。  `dplyr` 包的函数。\n\n*   **其他常用统计函数:**\n\n    *   **`cor()`:  相关系数** (度量两个数值型变量之间的线性相关程度)。\n    *   **`cov()`:  协方差** (度量两个数值型变量的协同变化程度)。\n    *   **`table()`:  频数统计表** (统计分类变量的频数分布)。\n    *   **`prop.table()`:  比例表** (将频数统计表转换为比例)。\n    *   **`summary()`:  摘要统计** (提供数据的基本摘要统计信息，包括均值、中位数、最小值、最大值、四分位数等)。  `summary()`  函数可以应用于不同类型的数据，提供不同的摘要信息。\n\n*   **统计函数的使用注意事项:**\n\n    *   **缺失值处理:**  R 的统计函数通常可以处理缺失值 (`NA`)。  大多数统计函数都有 `na.rm` 参数，用于控制是否移除缺失值。  `na.rm = TRUE`  表示在计算时移除缺失值，`na.rm = FALSE` (默认值) 表示如果数据中存在缺失值，则结果为 `NA`。  需要根据具体情况选择是否移除缺失值。\n    *   **数据类型:**  统计函数通常只适用于数值型数据。  对于字符型、因子型等非数值型数据，需要进行适当的转换或使用其他类型的统计方法。\n    *   **函数文档:**  R 的统计函数都有详细的帮助文档。  可以使用 `?函数名`  或 `help(\"函数名\")`  查看函数文档，了解函数的用法、参数和返回值。\n\n*   **统计函数练习:**  使用 `flights` 数据集，练习使用常用统计函数，例如：\n    ```r\n    # 计算 flights 数据集中 arr_delay (到达延误时间) 的均值、中位数、标准差\n    mean(flights$arr_delay, na.rm = TRUE)\n    median(flights$arr_delay, na.rm = TRUE)\n    sd(flights$arr_delay, na.rm = TRUE)\n\n    # 计算 carrier (航空公司) 的频数统计表\n    table(flights$carrier)\n\n    # 计算 origin (出发机场) 和 dest (到达机场) 的交叉频数表\n    table(flights$origin, flights$dest)\n\n    # 使用 summary() 函数查看 flights 数据集的摘要统计信息\n    summary(flights)\n    ```\n\n### 5. `dplyr` 包基础：数据框操作利器\n\n*   **`dplyr` 包简介:**  `dplyr` 包是 `tidyverse` 生态系统中的核心数据处理包，提供了一套简洁、高效、易用的数据框操作 \"动词\" (verbs)。  `dplyr`  的设计理念是 \"数据操作管道\" (data manipulation pipeline)，可以将多个数据操作步骤连接起来，形成清晰、可读性强的数据处理流程。  `dplyr`  是 R 语言数据分析中最常用的包之一。\n\n*   **`dplyr`  核心 \"动词\" (verbs):**  `dplyr`  包提供了以下几个核心 \"动词\"，用于完成常见的数据框操作：\n\n    *   **`filter()`:  筛选行** (根据条件筛选数据框的行)。  类似于 SQL 中的 `WHERE` 语句。\n    *   **`select()`:  选择列** (选择数据框的列)。  类似于 SQL 中的 `SELECT` 语句。\n    *   **`mutate()`:  创建新列或修改现有列** (基于现有列计算生成新列，或修改现有列的值)。\n    *   **`arrange()`:  排序** (根据指定的列对数据框进行排序)。  类似于 SQL 中的 `ORDER BY` 语句。\n    *   **`summarize()`:  汇总统计** (对数据框进行分组汇总统计，计算各种统计量)。  类似于 SQL 中的聚合函数 (例如 `SUM()`, `AVG()`, `COUNT()`) 和 `GROUP BY` 语句。\n    *   **`group_by()`:  分组** (将数据框按照指定的列进行分组，为后续的汇总统计操作做准备)。  类似于 SQL 中的 `GROUP BY` 语句。\n\n*   **管道操作符 `%>%`:**  `dplyr`  包与管道操作符 `%>%`  (pipe operator) 完美结合，可以实现链式数据操作。  管道操作符 `%>%`  将上一步操作的结果作为下一步操作的第一个参数传入，使得代码更加简洁、易读。  管道操作符来自 `magrittr` 包，`tidyverse`  自动加载 `magrittr` 包。\n\n*   **`dplyr`  基础用法示例 (使用 `flights` 数据集):**\n\n    *   **筛选行 (`filter()`):**  筛选出所有 1 月份 (month == 1) 的航班。\n        ```r\n        library(dplyr)\n\n        january_flights <- flights %>%\n          filter(month == 1)\n\n        print(january_flights)\n        ```\n        *   **`%>%` 管道操作符:**  `flights %>% filter(month == 1)`  表示将 `flights` 数据框作为 `filter()` 函数的第一个参数传入。\n        *   **`filter(month == 1)`:**  筛选条件是 `month == 1`，表示 `month` 列的值等于 1。  `==`  是等于比较运算符。\n\n    *   **选择列 (`select()`):**  选择 `year`, `month`, `day`, `carrier`, `flight`, `dep_delay`, `arr_delay`  这几列。\n        ```r\n        selected_cols_flights <- flights %>%\n          select(year, month, day, carrier, flight, dep_delay, arr_delay)\n\n        print(selected_cols_flights)\n        ```\n        *   **`select(year, month, day, carrier, flight, dep_delay, arr_delay)`:**  直接列出要选择的列名即可。\n\n    *   **创建新列 (`mutate()`):**  创建一个新列 `gain`，表示航班的实际飞行时间 (到达时间 - 出发时间 - 计划飞行时间)。\n        ```r\n        flights_with_gain <- flights %>%\n          mutate(gain = arr_time - dep_time - air_time)\n\n        print(flights_with_gain)\n        ```\n        *   **`mutate(gain = arr_time - dep_time - air_time)`:**  `gain = ...`  表示创建名为 `gain` 的新列，等号右边是计算新列值的表达式。\n\n    *   **排序 (`arrange()`):**  按照出发延误时间 `dep_delay`  进行升序排序。\n        ```r\n        arranged_flights <- flights %>%\n          arrange(dep_delay)\n\n        print(arranged_flights)\n        ```\n        *   **`arrange(dep_delay)`:**  按照 `dep_delay` 列进行升序排序。  默认升序。  降序排序可以使用 `desc(dep_delay)`。\n\n    *   **汇总统计 (`summarize()`):**  计算所有航班的平均到达延误时间 `arr_delay`。\n        ```r\n        average_delay <- flights %>%\n          summarize(mean_delay = mean(arr_delay, na.rm = TRUE))\n\n        print(average_delay)\n        ```\n        *   **`summarize(mean_delay = mean(arr_delay, na.rm = TRUE))`:**  `mean_delay = ...`  表示创建一个名为 `mean_delay` 的汇总统计量，等号右边是计算汇总统计量的表达式，这里使用 `mean()` 函数计算平均值，`na.rm = TRUE`  表示移除缺失值。\n\n    *   **分组汇总 (`group_by()` + `summarize()`):**  按照航空公司 `carrier`  分组，计算每个航空公司的平均到达延误时间。\n        ```r\n        carrier_delay <- flights %>%\n          group_by(carrier) %>%\n          summarize(mean_delay = mean(arr_delay, na.rm = TRUE))\n\n        print(carrier_delay)\n        ```\n        *   **`group_by(carrier)`:**  按照 `carrier` 列进行分组。  后续的 `summarize()`  操作将在每个分组内进行。\n        *   **`summarize(mean_delay = mean(arr_delay, na.rm = TRUE))`:**  在每个航空公司分组内计算平均到达延误时间。\n\n*   **`dplyr`  练习:**  鼓励学生使用 `dplyr`  的各种 \"动词\" 和管道操作符，对 `flights`  数据集进行各种数据操作练习，例如：\n    *   筛选出到达延误时间超过 60 分钟的航班。\n    *   选择 `carrier`, `flight`, `dep_delay`, `arr_delay`  和 `distance`  列，并按照飞行距离 `distance`  进行降序排序。\n    *   创建新列 `speed`，表示航班的平均飞行速度 (距离 / 飞行时间)。\n    *   按照出发机场 `origin`  分组，计算每个出发机场的航班数量和平均出发延误时间。\n    *   尝试组合多个 `dplyr`  动词，完成更复杂的数据操作任务。\n\n*   **AI 辅助 `dplyr`  使用 (可选):**  演示如何使用 AI 插件辅助 `dplyr`  包的使用。  例如：\n\n    *   **函数用法查询:**  使用 AI 聊天提问： \"`filter()` function in R `dplyr` package\",  \"how to use `group_by()` and `summarize()` in `dplyr`\"。  AI 可能会提供函数文档或使用示例。\n    *   **代码补全:**  在 VS Code/Cursor 中输入 `flights %>% fil`，AI 插件会自动提示 `filter()` 函数，并提供函数参数提示。\n    *   **代码示例生成:**  使用 AI 代码生成功能，输入注释:  `# R code to filter flights data for month == 2 and carrier == \"AA\" using dplyr`,  让 AI 生成代码。\n    *   **代码解释:**  使用 AI 代码解释功能，选中 `dplyr` 代码片段，让 AI 解释代码的功能和每一行代码的作用。\n\n### 6. 本周内容总结与下周预告\n\n*   **本周回顾:**  回顾本周学习内容，巩固重点知识。  本周我们**深入学习**了 R 语言数据导入的常用包 `readr` 和 `datatable`，对比了它们的特点和适用场景，学习了 R 的基本数据类型和常用统计函数，并初步掌握了 `dplyr` 包的基本用法。  **数据导入、数据类型、统计函数和 `dplyr`  是 R 语言数据分析的基础，务必熟练掌握本周所学内容。**\n\n*   **下周预告:**  下周我们将继续深入学习 `dplyr` 包，学习更高级的数据操作技巧，例如，多表连接 (join)、数据变形 (reshape)、窗口函数 (window function) 等。  `dplyr`  是数据清洗和预处理的利器，下周我们将重点学习如何使用 `dplyr`  进行高效的数据清洗和预处理。\n\n### 7. 课后任务\n\n*   **小组任务:**\n    *   **继续项目一数据探索:**  各小组继续使用 R 语言导入和探索项目一的数据集，尝试使用 `readr` 或 `datatable` 包导入数据，并使用本周学习的 R 基础知识和 `dplyr`  包进行初步的数据查看和理解。\n    *   **小组讨论数据清洗方案:**  小组讨论项目一的数据清洗和预处理方案，为下周的数据清洗任务做好准备。\n\n*   **个人任务:**\n    *   **复习本周内容:**  回顾本周讲义和课堂笔记，巩固 `readr` 和 `datatable` 包的用法、R 基本数据类型、常用统计函数和 `dplyr`  基础用法。\n    *   **R 代码练习:**  完成本讲义中布置的 R 代码练习，熟练掌握 `readr`, `datatable`, R 基础函数和 `dplyr`  包的常用函数。  尝试使用 AI 插件辅助 R 代码练习。\n    *   **`flights` 数据集练习:**  使用 `flights`  数据集，练习使用 `readr` 和 `datatable`  进行数据导入导出，练习使用 R 基本数据类型和统计函数，练习使用 `dplyr`  包进行数据操作。  可以尝试完成讲义中提供的练习题，也可以自己设计练习题。\n\n::: {.callout-tip}\n## AI 辅助学习小贴士\n\n*   **R 代码练习:**  继续在 VS Code 或 Cursor 中练习 R 语言代码，充分利用 AI 插件的代码自动补全、代码生成、代码解释、AI 聊天等功能。  遇到 R 代码问题，及时向 AI 提问。\n*   **数据包使用问题:**  如果在使用 `readr`, `datatable`, `dplyr`  等数据包时遇到问题，可以查阅包的官方文档，或者使用 AI 聊天提问，寻求帮助。\n*   **统计概念理解:**  如果对某些统计概念 (例如，均值、中位数、标准差、相关系数等) 理解不透彻，可以使用 AI 聊天提问，让 AI 提供更详细的解释和例子。\n*   **代码效率优化:**  如果希望提高 R 代码的运行效率，可以尝试使用 `datatable` 包，或者使用 AI 聊天咨询代码优化技巧。\n:::\n\n::: {.callout-note}\n## 学习寄语\n\n**工欲善其事，必先利其器！  本周我们学习了 R 语言数据导入和数据处理的利器，为后续的数据分析打下了坚实的基础。  熟练掌握这些工具，您将能够更高效地进行数据分析！**  继续保持学习的热情，充分利用 VS Code/Cursor 和 AI 插件的强大功能，相信大家会在统计学和 R 语言的学习中取得更大的进步！  下周见！\n::: ","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles/custom.css","styles/mermaid.css"],"number-sections":false,"toc":true,"toc-depth":3,"output-file":"week02.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","theme":"cosmo"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}