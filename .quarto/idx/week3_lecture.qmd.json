{"title":"第三周：数据整形：`tidyverse` 的核心技艺","markdown":{"yaml":{"title":"第三周：数据整形：`tidyverse` 的核心技艺","execute":{"echo":true,"message":false,"warning":false,"error":false,"cache":false}},"headingText":"1. `dplyr` 进阶：更强大的数据操作","containsRefs":false,"markdown":"\n\n\n上周我们学习了 `dplyr` 的 `select()` 和 `filter()`。本周我们将学习更多核心动词，让数据操作如虎添翼。\n\n::: {.callout-note title=\"本周目标\"}\n-   掌握 `dplyr` 的核心数据转换动词：`mutate()`, `arrange()`, `group_by()`, `summarise()`。\n-   理解并应用 `tidyr` 进行数据长宽格式转换：`pivot_longer()`, `pivot_wider()`。\n-   掌握\"整洁数据\" (Tidy Data) 的核心原则。\n-   学习处理数据中的缺失值 (NA)。\n-   熟练运用管道 (`%>%`) 连接多步数据处理操作。\n:::\n\n我们将继续使用上周创建的 `students_data` Tibble，并可能引入新的示例数据。\n\n```{r setup-data}\nlibrary(tidyverse)\n\n# 回顾上周数据 (或重新创建)\ncsv_text <- \"Name,Age,Major,GPA\\nAlice,21,Statistics,3.8\\nBob,22,Computer Science,3.5\\nCharlie,20,Mathematics,3.9\\nDavid,21,Statistics,3.6\"\nstudents_data <- read_csv(csv_text)\n\n# 引入一个更复杂的数据集用于演示 group_by 和 summarise\nexam_scores <- tibble(\n  StudentID = c(101, 102, 101, 103, 102, 103, 101),\n  Exam = c(\"Midterm\", \"Midterm\", \"Final\", \"Midterm\", \"Final\", \"Final\", \"Quiz1\"),\n  Score = c(85, 90, 88, 75, 92, 80, 95)\n)\n\nprint(students_data)\nprint(exam_scores)\n```\n\n-   **`mutate()`: 创建或修改列**\n\n    -   基于现有列计算新列，或修改现有列。\n    -   新列会添加到数据框的末尾。\n\n    ```{r mutate-example}\n    # 示例1: 计算 GPA 相对于 4.0 的差距\n    students_data %>%\n      mutate(GPA_diff = 4.0 - GPA)\n\n    # 示例2: 创建一个表示年龄是否大于21岁的逻辑列\n    students_data %>%\n      mutate(Is_Over_21 = Age > 21)\n\n    # 示例3: 同时创建多个列\n    students_data %>%\n      mutate(\n        GPA_diff = 4.0 - GPA,\n        Birth_Year = 2024 - Age # 假设当前是2024年\n      )\n\n    # 示例4: 修改现有列 (例如，将 GPA 乘以 25 得到百分制)\n    students_data %>%\n      mutate(GPA_percent = GPA * 25) # 创建新列\n\n    # 示例5: 直接修改原列 (需谨慎)\n    students_data %>%\n      mutate(GPA = GPA * 25)\n    ```\n\n-   **`arrange()`: 按列排序行**\n\n    -   默认升序排列。\n    -   使用 `desc()` 进行降序排列。\n    -   可以按多个列排序。\n\n    ```{r arrange-example}\n    # 按年龄升序排序\n    students_data %>% arrange(Age)\n\n    # 按 GPA 降序排序\n    students_data %>% arrange(desc(GPA))\n\n    # 先按专业升序，再按 GPA 降序\n    students_data %>% arrange(Major, desc(GPA))\n    ```\n\n-   **`group_by()`: 按分类变量分组**\n\n    -   本身不改变数据外观，但会为后续操作（主要是 `summarise()`）添加分组信息。\n    -   后续操作将在每个分组内部独立进行。\n\n    ```{r group-by-example}\n    # 按专业分组 (输出看起来没变，但内部结构变了)\n    students_data %>% group_by(Major)\n\n    # 按学生ID分组 exam_scores 数据\n    exam_scores %>% group_by(StudentID)\n    ```\n\n-   **`summarise()` (或 `summarize()`): 数据汇总**\n\n    -   通常与 `group_by()` 结合使用，对每个分组进行汇总计算。\n    -   创建包含汇总统计量的新数据框。\n    -   常用的汇总函数：`mean()`, `median()`, `sd()`, `var()`, `min()`, `max()`, `n()` (计算行数/观测数), `n_distinct()` (计算唯一值数量)。\n\n    ```{r summarise-example}\n    # 计算所有学生的平均年龄和最高 GPA (没有 group_by)\n    students_data %>%\n      summarise(\n        Avg_Age = mean(Age),\n        Max_GPA = max(GPA)\n      )\n\n    # 计算每个专业的学生人数和平均 GPA\n    students_data %>%\n      group_by(Major) %>%\n      summarise(\n        Num_Students = n(), # n() 计算当前分组的行数\n        Avg_GPA = mean(GPA, na.rm = TRUE) # 好习惯：处理可能的NA\n      )\n\n    # 计算每个学生的考试次数和平均分\n    exam_scores %>%\n      group_by(StudentID) %>%\n      summarise(\n        Num_Exams = n(),\n        Avg_Score = mean(Score),\n        Min_Score = min(Score),\n        Max_Score = max(Score)\n      )\n\n    # 计算每门考试的参加人数和最高分\n    exam_scores %>%\n      group_by(Exam) %>%\n      summarise(\n        Num_Participants = n_distinct(StudentID), # 统计不重复的学生ID数\n        Highest_Score = max(Score)\n      )\n    ```\n\n    ::: {.callout-tip title=\"`ungroup()`\"}\n    使用 `group_by()` 后，数据会保持分组状态。如果后续操作希望在整个数据集上进行，而不是分组进行，需要使用 `ungroup()` 取消分组。\n\n    ```{r ungroup-example}\n    students_data %>%\n      group_by(Major) %>%\n      mutate(Major_Avg_GPA = mean(GPA)) %>% # 在分组内计算平均GPA\n      ungroup() %>% # 取消分组\n      mutate(Overall_Avg_GPA = mean(GPA)) # 在全体数据上计算总平均GPA\n    ```\n    :::\n\n## 2. 整洁数据 (Tidy Data) 的理念\n\n\"整洁数据\" 是由 Hadley Wickham 提出的数据组织标准，旨在简化数据分析流程。遵循整洁数据原则的数据更易于使用 `tidyverse` 工具进行处理和可视化。\n\n-   **三条核心原则:**\n    1.  **每个变量构成一列 (Each variable forms a column)。**\n    2.  **每个观测构成一行 (Each observation forms a row)。**\n    3.  **每种类型的观测单元构成一个表格 (Each type of observational unit forms a table)。**\n-   **为何重要？**\n    -   `tidyverse` 中的函数（`dplyr`, `ggplot2` 等）都设计为处理整洁数据。\n    -   使数据结构标准化，便于理解和协作。\n    -   简化数据清理和转换步骤。\n-   **不整洁数据的常见形式:**\n    -   列名是变量值，而不是变量名 (例如，年份作为列名)。\n    -   一个单元格中存储了多个值。\n    -   变量同时存储在行和列中。\n\n## 3. `tidyr`: 让数据更整洁\n\n`tidyr` 包提供了将数据在\"宽\"格式和\"长\"格式之间转换的函数，帮助我们将数据整理成\"整洁\"的形式。\n\n-   **宽数据 (Wide Data):** 通常人类阅读更友好，但不利于计算。变量值可能作为列名。\n\n-   **长数据 (Long Data):** 通常更符合整洁数据原则，便于 `tidyverse` 处理。每个观测的关键信息都在行内，变量名在列中。\n\n-   **核心函数:**\n\n    -   `pivot_longer()`: 将**宽数据变长**。将多个列\"融合\"成键-值对的两列。\n    -   `pivot_wider()`: 将**长数据变宽**。根据键-值对将数据\"展开\"到多个列。\n\n-   **`pivot_longer()` 示例:** 假设我们有如下\"宽\"格式数据，记录了不同季度销售额：\n    \n    ```{r}\n    sales_wide <- tibble(\n      Product = c(\"A\", \"B\"),\n      Qtr1 = c(100, 150),\n      Qtr2 = c(110, 160),\n      Qtr3 = c(120, 170),\n      Qtr4 = c(130, 180)\n      )\n      \n      print(sales_wide)\n    ```\n      \n    这里的列名 `Qtr1` 到 `Qtr4` 实际上是\"季度\"这个变量的值。我们希望将其转换为整洁的长格式：\n    ```{r}\n    sales_long <- sales_wide %>%\n      pivot_longer(\n        cols = Qtr1:Qtr4, # 指定哪些列需要被转换 (这里是 Qtr1 到 Qtr4) \n        names_to = \"Quarter\",  # 新列名，用于存储原来的列名 (Qtr1, Qtr2...)\n        values_to = \"Sales\"    # 新列名，用于存储原来的单元格值\n      )\n    \n    print(sales_long)\n    ```\n      \n      现在，每个观测（某个产品在某个季度的销售额）都独占一行，变量（产品、季度、销售额）各自成列。\n\n-   **`pivot_wider()` 示例:** 将刚才的长数据 `sales_long` 转换回宽数据： \n\n    ```{r}\n    sales_regained_wide <- sales_long %>%\n      pivot_wider(\n        names_from = Quarter, # 指定包含新列名的列 (Quarter)\n        values_from = Sales   # 指定包含新单元格值的列 (Sales)\n        )\n        \n    print(sales_regained_wide)\n    ```\n\n## 4. 处理缺失值 (NA)\n\n缺失值 (NA, Not Available) 在真实数据中非常常见。`dplyr` 和 `tidyr` 以及 R 基础函数提供了处理它们的方法。\n\n-   **识别缺失值:** `is.na()` 函数返回一个逻辑向量，`TRUE` 表示对应位置是 NA。\n\n    ```{r}\n    x <- c(1, 2, NA, 4, NA)\n    is.na(x)\n\n    # 在数据框中使用 (例如，检查 exam_scores 中是否有 NA)\n    is.na(exam_scores) # 返回一个与数据框同样大小的逻辑矩阵\n    any(is.na(exam_scores)) # 检查整个数据框是否有任何 NA\n    colSums(is.na(exam_scores)) # 计算每列的 NA 数量\n    ```\n\n-   **处理策略:**\n\n    1.  **删除:**\n\n        -   `na.omit()` (基础 R): 删除**任何列**包含 NA 的**整行**。简单粗暴，可能丢失过多信息。\n        -   `drop_na()` (`tidyr`): 功能类似 `na.omit()`, 但可以指定只检查某些列的 NA。\n\n    ```{r}\n    scores_na_df <- tibble(ID = 1:6, Score = c(85, 92, NA, 88, 95, 72))\n    print(scores_na_df)\n\n    na.omit(scores_na_df) # 删除包含 NA 的行\n\n    library(tidyr)\n    scores_na_df %>% drop_na() # 同上\n\n    # 假设有另一列，我们只想删除 Score 为 NA 的行\n    scores_na_df2 <- tibble(\n      ID = 1:6,\n      Score = c(85, 92, NA, 88, 95, 72),\n      Group = c(\"A\", \"B\", \"A\", NA, \"B\", \"A\")\n      )\n    print(scores_na_df2)\n    scores_na_df2 %>% drop_na(Score) # 只检查 Score 列的 NA\n    ```\n\n    2.  **填充/插补 (Imputation):** 用某个值（如均值、中位数、众数或模型预测值）替换 NA。这更复杂，需要根据具体情况选择合适的方法（后续课程可能涉及）。\n\n    -   `replace_na()` (`tidyr`): 用指定值替换 NA。\n\n    ```{r}\n    scores_na_df %>%\n      mutate(Score_filled = replace_na(Score, mean(Score, na.rm = TRUE))) # 用均值填充\n    ```\n\n    3.  **在计算中忽略:** 许多函数（如 `mean()`, `sum()`, `sd()` 等）有 `na.rm = TRUE` 参数。 \n    \n    ```{r}\n    mean(scores_na_df$Score) # NA\n    mean(scores_na_df$Score, na.rm = TRUE) # 正确计算\n    ```\n\n::: {.callout-warning title=\"处理 NA 的重要性\"}\n不恰当处理 NA 会导致分析结果偏差甚至错误。选择哪种策略取决于数据的性质、缺失的原因以及分析的目标。删除是最简单的方法，但只有在 NA 占比很小或确定该观测无效时才推荐。\n:::\n\n## 5. 管道 (`%>%`) 连接多步操作\n\n管道使得复杂的数据处理流程清晰易读。\n\n-   **示例：** 从 `exam_scores` 数据中，找出每个学生（StudentID）的最高分（Max_Score），并按最高分降序排列，最后只显示 StudentID 和 Max_Score。\n    ```{r}\n    exam_scores %>%\n      group_by(StudentID) %>% # 按学生分组\n      summarise(Max_Score = max(Score)) %>% # 计算每个学生的最高分\n      arrange(desc(Max_Score)) %>% # 按最高分降序排列\n      ungroup() # 最好取消分组（虽然这里影响不大）\n    ```\n\n-   **对比不使用管道的代码：**\n    ```{r}\n    grouped_data <- group_by(exam_scores, StudentID)\n    summary_data <- summarise(grouped_data, Max_Score = max(Score))\n    arranged_data <- arrange(summary_data, desc(Max_Score))\n    ungroup(arranged_data)\n    ```\n\n管道显然更简洁、更符合思维流程。\n\n## 6. 项目相关与本周总结\n\n-   **项目任务:**\n    -   应用本周学到的 `dplyr` 动词（`mutate`, `arrange`, `group_by`, `summarise`）对你的项目数据进行初步的探索性分析。例如，计算分组统计量，创建新变量，按特定条件排序。\n    -   检查你的项目数据是否符合\"整洁数据\"原则。如果不符合，思考如何使用 `pivot_longer` 或 `pivot_wider` 进行转换（如果适用）。\n    -   检查项目数据中的缺失值 (`is.na()`, `colSums(is.na())`)。思考初步的处理策略（暂时可以先记录下来，不一定立即处理）。\n-   **本周回顾:** 我们掌握了 `dplyr` 的核心转换函数和 `tidyr` 的长宽格式转换，理解了整洁数据的重要性，并学习了处理缺失值的基本方法。通过管道，我们可以将这些操作流畅地组合起来，高效地完成数据整形任务。\n\n**下周预告:** 数据准备就绪，是时候让数据\"说话\"了！我们将学习强大的可视化工具 `ggplot2`，探索如何通过图形发现数据中的模式和洞见，并初步接触推断统计的思想。","srcMarkdownNoYaml":"\n\n## 1. `dplyr` 进阶：更强大的数据操作\n\n上周我们学习了 `dplyr` 的 `select()` 和 `filter()`。本周我们将学习更多核心动词，让数据操作如虎添翼。\n\n::: {.callout-note title=\"本周目标\"}\n-   掌握 `dplyr` 的核心数据转换动词：`mutate()`, `arrange()`, `group_by()`, `summarise()`。\n-   理解并应用 `tidyr` 进行数据长宽格式转换：`pivot_longer()`, `pivot_wider()`。\n-   掌握\"整洁数据\" (Tidy Data) 的核心原则。\n-   学习处理数据中的缺失值 (NA)。\n-   熟练运用管道 (`%>%`) 连接多步数据处理操作。\n:::\n\n我们将继续使用上周创建的 `students_data` Tibble，并可能引入新的示例数据。\n\n```{r setup-data}\nlibrary(tidyverse)\n\n# 回顾上周数据 (或重新创建)\ncsv_text <- \"Name,Age,Major,GPA\\nAlice,21,Statistics,3.8\\nBob,22,Computer Science,3.5\\nCharlie,20,Mathematics,3.9\\nDavid,21,Statistics,3.6\"\nstudents_data <- read_csv(csv_text)\n\n# 引入一个更复杂的数据集用于演示 group_by 和 summarise\nexam_scores <- tibble(\n  StudentID = c(101, 102, 101, 103, 102, 103, 101),\n  Exam = c(\"Midterm\", \"Midterm\", \"Final\", \"Midterm\", \"Final\", \"Final\", \"Quiz1\"),\n  Score = c(85, 90, 88, 75, 92, 80, 95)\n)\n\nprint(students_data)\nprint(exam_scores)\n```\n\n-   **`mutate()`: 创建或修改列**\n\n    -   基于现有列计算新列，或修改现有列。\n    -   新列会添加到数据框的末尾。\n\n    ```{r mutate-example}\n    # 示例1: 计算 GPA 相对于 4.0 的差距\n    students_data %>%\n      mutate(GPA_diff = 4.0 - GPA)\n\n    # 示例2: 创建一个表示年龄是否大于21岁的逻辑列\n    students_data %>%\n      mutate(Is_Over_21 = Age > 21)\n\n    # 示例3: 同时创建多个列\n    students_data %>%\n      mutate(\n        GPA_diff = 4.0 - GPA,\n        Birth_Year = 2024 - Age # 假设当前是2024年\n      )\n\n    # 示例4: 修改现有列 (例如，将 GPA 乘以 25 得到百分制)\n    students_data %>%\n      mutate(GPA_percent = GPA * 25) # 创建新列\n\n    # 示例5: 直接修改原列 (需谨慎)\n    students_data %>%\n      mutate(GPA = GPA * 25)\n    ```\n\n-   **`arrange()`: 按列排序行**\n\n    -   默认升序排列。\n    -   使用 `desc()` 进行降序排列。\n    -   可以按多个列排序。\n\n    ```{r arrange-example}\n    # 按年龄升序排序\n    students_data %>% arrange(Age)\n\n    # 按 GPA 降序排序\n    students_data %>% arrange(desc(GPA))\n\n    # 先按专业升序，再按 GPA 降序\n    students_data %>% arrange(Major, desc(GPA))\n    ```\n\n-   **`group_by()`: 按分类变量分组**\n\n    -   本身不改变数据外观，但会为后续操作（主要是 `summarise()`）添加分组信息。\n    -   后续操作将在每个分组内部独立进行。\n\n    ```{r group-by-example}\n    # 按专业分组 (输出看起来没变，但内部结构变了)\n    students_data %>% group_by(Major)\n\n    # 按学生ID分组 exam_scores 数据\n    exam_scores %>% group_by(StudentID)\n    ```\n\n-   **`summarise()` (或 `summarize()`): 数据汇总**\n\n    -   通常与 `group_by()` 结合使用，对每个分组进行汇总计算。\n    -   创建包含汇总统计量的新数据框。\n    -   常用的汇总函数：`mean()`, `median()`, `sd()`, `var()`, `min()`, `max()`, `n()` (计算行数/观测数), `n_distinct()` (计算唯一值数量)。\n\n    ```{r summarise-example}\n    # 计算所有学生的平均年龄和最高 GPA (没有 group_by)\n    students_data %>%\n      summarise(\n        Avg_Age = mean(Age),\n        Max_GPA = max(GPA)\n      )\n\n    # 计算每个专业的学生人数和平均 GPA\n    students_data %>%\n      group_by(Major) %>%\n      summarise(\n        Num_Students = n(), # n() 计算当前分组的行数\n        Avg_GPA = mean(GPA, na.rm = TRUE) # 好习惯：处理可能的NA\n      )\n\n    # 计算每个学生的考试次数和平均分\n    exam_scores %>%\n      group_by(StudentID) %>%\n      summarise(\n        Num_Exams = n(),\n        Avg_Score = mean(Score),\n        Min_Score = min(Score),\n        Max_Score = max(Score)\n      )\n\n    # 计算每门考试的参加人数和最高分\n    exam_scores %>%\n      group_by(Exam) %>%\n      summarise(\n        Num_Participants = n_distinct(StudentID), # 统计不重复的学生ID数\n        Highest_Score = max(Score)\n      )\n    ```\n\n    ::: {.callout-tip title=\"`ungroup()`\"}\n    使用 `group_by()` 后，数据会保持分组状态。如果后续操作希望在整个数据集上进行，而不是分组进行，需要使用 `ungroup()` 取消分组。\n\n    ```{r ungroup-example}\n    students_data %>%\n      group_by(Major) %>%\n      mutate(Major_Avg_GPA = mean(GPA)) %>% # 在分组内计算平均GPA\n      ungroup() %>% # 取消分组\n      mutate(Overall_Avg_GPA = mean(GPA)) # 在全体数据上计算总平均GPA\n    ```\n    :::\n\n## 2. 整洁数据 (Tidy Data) 的理念\n\n\"整洁数据\" 是由 Hadley Wickham 提出的数据组织标准，旨在简化数据分析流程。遵循整洁数据原则的数据更易于使用 `tidyverse` 工具进行处理和可视化。\n\n-   **三条核心原则:**\n    1.  **每个变量构成一列 (Each variable forms a column)。**\n    2.  **每个观测构成一行 (Each observation forms a row)。**\n    3.  **每种类型的观测单元构成一个表格 (Each type of observational unit forms a table)。**\n-   **为何重要？**\n    -   `tidyverse` 中的函数（`dplyr`, `ggplot2` 等）都设计为处理整洁数据。\n    -   使数据结构标准化，便于理解和协作。\n    -   简化数据清理和转换步骤。\n-   **不整洁数据的常见形式:**\n    -   列名是变量值，而不是变量名 (例如，年份作为列名)。\n    -   一个单元格中存储了多个值。\n    -   变量同时存储在行和列中。\n\n## 3. `tidyr`: 让数据更整洁\n\n`tidyr` 包提供了将数据在\"宽\"格式和\"长\"格式之间转换的函数，帮助我们将数据整理成\"整洁\"的形式。\n\n-   **宽数据 (Wide Data):** 通常人类阅读更友好，但不利于计算。变量值可能作为列名。\n\n-   **长数据 (Long Data):** 通常更符合整洁数据原则，便于 `tidyverse` 处理。每个观测的关键信息都在行内，变量名在列中。\n\n-   **核心函数:**\n\n    -   `pivot_longer()`: 将**宽数据变长**。将多个列\"融合\"成键-值对的两列。\n    -   `pivot_wider()`: 将**长数据变宽**。根据键-值对将数据\"展开\"到多个列。\n\n-   **`pivot_longer()` 示例:** 假设我们有如下\"宽\"格式数据，记录了不同季度销售额：\n    \n    ```{r}\n    sales_wide <- tibble(\n      Product = c(\"A\", \"B\"),\n      Qtr1 = c(100, 150),\n      Qtr2 = c(110, 160),\n      Qtr3 = c(120, 170),\n      Qtr4 = c(130, 180)\n      )\n      \n      print(sales_wide)\n    ```\n      \n    这里的列名 `Qtr1` 到 `Qtr4` 实际上是\"季度\"这个变量的值。我们希望将其转换为整洁的长格式：\n    ```{r}\n    sales_long <- sales_wide %>%\n      pivot_longer(\n        cols = Qtr1:Qtr4, # 指定哪些列需要被转换 (这里是 Qtr1 到 Qtr4) \n        names_to = \"Quarter\",  # 新列名，用于存储原来的列名 (Qtr1, Qtr2...)\n        values_to = \"Sales\"    # 新列名，用于存储原来的单元格值\n      )\n    \n    print(sales_long)\n    ```\n      \n      现在，每个观测（某个产品在某个季度的销售额）都独占一行，变量（产品、季度、销售额）各自成列。\n\n-   **`pivot_wider()` 示例:** 将刚才的长数据 `sales_long` 转换回宽数据： \n\n    ```{r}\n    sales_regained_wide <- sales_long %>%\n      pivot_wider(\n        names_from = Quarter, # 指定包含新列名的列 (Quarter)\n        values_from = Sales   # 指定包含新单元格值的列 (Sales)\n        )\n        \n    print(sales_regained_wide)\n    ```\n\n## 4. 处理缺失值 (NA)\n\n缺失值 (NA, Not Available) 在真实数据中非常常见。`dplyr` 和 `tidyr` 以及 R 基础函数提供了处理它们的方法。\n\n-   **识别缺失值:** `is.na()` 函数返回一个逻辑向量，`TRUE` 表示对应位置是 NA。\n\n    ```{r}\n    x <- c(1, 2, NA, 4, NA)\n    is.na(x)\n\n    # 在数据框中使用 (例如，检查 exam_scores 中是否有 NA)\n    is.na(exam_scores) # 返回一个与数据框同样大小的逻辑矩阵\n    any(is.na(exam_scores)) # 检查整个数据框是否有任何 NA\n    colSums(is.na(exam_scores)) # 计算每列的 NA 数量\n    ```\n\n-   **处理策略:**\n\n    1.  **删除:**\n\n        -   `na.omit()` (基础 R): 删除**任何列**包含 NA 的**整行**。简单粗暴，可能丢失过多信息。\n        -   `drop_na()` (`tidyr`): 功能类似 `na.omit()`, 但可以指定只检查某些列的 NA。\n\n    ```{r}\n    scores_na_df <- tibble(ID = 1:6, Score = c(85, 92, NA, 88, 95, 72))\n    print(scores_na_df)\n\n    na.omit(scores_na_df) # 删除包含 NA 的行\n\n    library(tidyr)\n    scores_na_df %>% drop_na() # 同上\n\n    # 假设有另一列，我们只想删除 Score 为 NA 的行\n    scores_na_df2 <- tibble(\n      ID = 1:6,\n      Score = c(85, 92, NA, 88, 95, 72),\n      Group = c(\"A\", \"B\", \"A\", NA, \"B\", \"A\")\n      )\n    print(scores_na_df2)\n    scores_na_df2 %>% drop_na(Score) # 只检查 Score 列的 NA\n    ```\n\n    2.  **填充/插补 (Imputation):** 用某个值（如均值、中位数、众数或模型预测值）替换 NA。这更复杂，需要根据具体情况选择合适的方法（后续课程可能涉及）。\n\n    -   `replace_na()` (`tidyr`): 用指定值替换 NA。\n\n    ```{r}\n    scores_na_df %>%\n      mutate(Score_filled = replace_na(Score, mean(Score, na.rm = TRUE))) # 用均值填充\n    ```\n\n    3.  **在计算中忽略:** 许多函数（如 `mean()`, `sum()`, `sd()` 等）有 `na.rm = TRUE` 参数。 \n    \n    ```{r}\n    mean(scores_na_df$Score) # NA\n    mean(scores_na_df$Score, na.rm = TRUE) # 正确计算\n    ```\n\n::: {.callout-warning title=\"处理 NA 的重要性\"}\n不恰当处理 NA 会导致分析结果偏差甚至错误。选择哪种策略取决于数据的性质、缺失的原因以及分析的目标。删除是最简单的方法，但只有在 NA 占比很小或确定该观测无效时才推荐。\n:::\n\n## 5. 管道 (`%>%`) 连接多步操作\n\n管道使得复杂的数据处理流程清晰易读。\n\n-   **示例：** 从 `exam_scores` 数据中，找出每个学生（StudentID）的最高分（Max_Score），并按最高分降序排列，最后只显示 StudentID 和 Max_Score。\n    ```{r}\n    exam_scores %>%\n      group_by(StudentID) %>% # 按学生分组\n      summarise(Max_Score = max(Score)) %>% # 计算每个学生的最高分\n      arrange(desc(Max_Score)) %>% # 按最高分降序排列\n      ungroup() # 最好取消分组（虽然这里影响不大）\n    ```\n\n-   **对比不使用管道的代码：**\n    ```{r}\n    grouped_data <- group_by(exam_scores, StudentID)\n    summary_data <- summarise(grouped_data, Max_Score = max(Score))\n    arranged_data <- arrange(summary_data, desc(Max_Score))\n    ungroup(arranged_data)\n    ```\n\n管道显然更简洁、更符合思维流程。\n\n## 6. 项目相关与本周总结\n\n-   **项目任务:**\n    -   应用本周学到的 `dplyr` 动词（`mutate`, `arrange`, `group_by`, `summarise`）对你的项目数据进行初步的探索性分析。例如，计算分组统计量，创建新变量，按特定条件排序。\n    -   检查你的项目数据是否符合\"整洁数据\"原则。如果不符合，思考如何使用 `pivot_longer` 或 `pivot_wider` 进行转换（如果适用）。\n    -   检查项目数据中的缺失值 (`is.na()`, `colSums(is.na())`)。思考初步的处理策略（暂时可以先记录下来，不一定立即处理）。\n-   **本周回顾:** 我们掌握了 `dplyr` 的核心转换函数和 `tidyr` 的长宽格式转换，理解了整洁数据的重要性，并学习了处理缺失值的基本方法。通过管道，我们可以将这些操作流畅地组合起来，高效地完成数据整形任务。\n\n**下周预告:** 数据准备就绪，是时候让数据\"说话\"了！我们将学习强大的可视化工具 `ggplot2`，探索如何通过图形发现数据中的模式和洞见，并初步接触推断统计的思想。"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":false,"freeze":false,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"message":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles/custom.css"],"toc":true,"number-sections":false,"include-in-header":[{"text":"<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css\" integrity=\"sha512-1ycn6IcaQQ40/MKBW2W4Rhis/DbILU74C1vSrLJxCq57o941Ym01SwNsOMqvEBFlcgUa6xkm/sYwpb+ilR5gUw==\" crossorigin=\"anonymous\" referrerpolicy=\"no-referrer\">\n"}],"output-file":"week3_lecture.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","knitr":{"opts_chunk":{"comment":"#>","fig.align":"center","fig.width":8,"fig.height":6,"out.width":"90%","dpi":300,"dev":"ragg_png"}},"theme":"cosmo","callout-appearance":"none","message":false,"title":"第三周：数据整形：`tidyverse` 的核心技艺"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}