{
  "hash": "68727a2b74e5ff7b8dbeae86aacf641d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"第三周：数据整形：`tidyverse` 的核心技艺\"\nexecute:\n  echo: true\n  message: false\n  warning: false\n  error: false\n  cache: false\n---\n\n\n\n\n## 1. `dplyr` 进阶：更强大的数据操作\n\n上周我们学习了 `dplyr` 的 `select()` 和 `filter()`。本周我们将学习更多核心动词，让数据操作如虎添翼。\n\n::: {.callout-note title=\"本周目标\"}\n-   掌握 `dplyr` 的核心数据转换动词：`mutate()`, `arrange()`, `group_by()`, `summarise()`。\n-   理解并应用 `tidyr` 进行数据长宽格式转换：`pivot_longer()`, `pivot_wider()`。\n-   掌握\"整洁数据\" (Tidy Data) 的核心原则。\n-   学习处理数据中的缺失值 (NA)。\n-   熟练运用管道 (`%>%`) 连接多步数据处理操作。\n:::\n\n我们将继续使用上周创建的 `students_data` Tibble，并可能引入新的示例数据。\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\n# 回顾上周数据 (或重新创建)\ncsv_text <- \"Name,Age,Major,GPA\\nAlice,21,Statistics,3.8\\nBob,22,Computer Science,3.5\\nCharlie,20,Mathematics,3.9\\nDavid,21,Statistics,3.6\"\nstudents_data <- read_csv(csv_text)\n\n# 引入一个更复杂的数据集用于演示 group_by 和 summarise\nexam_scores <- tibble(\n  StudentID = c(101, 102, 101, 103, 102, 103, 101),\n  Exam = c(\"Midterm\", \"Midterm\", \"Final\", \"Midterm\", \"Final\", \"Final\", \"Quiz1\"),\n  Score = c(85, 90, 88, 75, 92, 80, 95)\n)\n\nprint(students_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 4 × 4\n#>   Name      Age Major              GPA\n#>   <chr>   <dbl> <chr>            <dbl>\n#> 1 Alice      21 Statistics         3.8\n#> 2 Bob        22 Computer Science   3.5\n#> 3 Charlie    20 Mathematics        3.9\n#> 4 David      21 Statistics         3.6\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(exam_scores)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 7 × 3\n#>   StudentID Exam    Score\n#>       <dbl> <chr>   <dbl>\n#> 1       101 Midterm    85\n#> 2       102 Midterm    90\n#> 3       101 Final      88\n#> 4       103 Midterm    75\n#> 5       102 Final      92\n#> 6       103 Final      80\n#> 7       101 Quiz1      95\n```\n\n\n:::\n:::\n\n\n\n\n-   **`mutate()`: 创建或修改列**\n\n    -   基于现有列计算新列，或修改现有列。\n    -   新列会添加到数据框的末尾。\n\n\n\n\n    ::: {.cell layout-align=\"center\"}\n    \n    ```{.r .cell-code}\n    # 示例1: 计算 GPA 相对于 4.0 的差距\n    students_data %>%\n      mutate(GPA_diff = 4.0 - GPA)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    #> # A tibble: 4 × 5\n    #>   Name      Age Major              GPA GPA_diff\n    #>   <chr>   <dbl> <chr>            <dbl>    <dbl>\n    #> 1 Alice      21 Statistics         3.8    0.200\n    #> 2 Bob        22 Computer Science   3.5    0.5  \n    #> 3 Charlie    20 Mathematics        3.9    0.100\n    #> 4 David      21 Statistics         3.6    0.4\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    # 示例2: 创建一个表示年龄是否大于21岁的逻辑列\n    students_data %>%\n      mutate(Is_Over_21 = Age > 21)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    #> # A tibble: 4 × 5\n    #>   Name      Age Major              GPA Is_Over_21\n    #>   <chr>   <dbl> <chr>            <dbl> <lgl>     \n    #> 1 Alice      21 Statistics         3.8 FALSE     \n    #> 2 Bob        22 Computer Science   3.5 TRUE      \n    #> 3 Charlie    20 Mathematics        3.9 FALSE     \n    #> 4 David      21 Statistics         3.6 FALSE\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    # 示例3: 同时创建多个列\n    students_data %>%\n      mutate(\n        GPA_diff = 4.0 - GPA,\n        Birth_Year = 2024 - Age # 假设当前是2024年\n      )\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    #> # A tibble: 4 × 6\n    #>   Name      Age Major              GPA GPA_diff Birth_Year\n    #>   <chr>   <dbl> <chr>            <dbl>    <dbl>      <dbl>\n    #> 1 Alice      21 Statistics         3.8    0.200       2003\n    #> 2 Bob        22 Computer Science   3.5    0.5         2002\n    #> 3 Charlie    20 Mathematics        3.9    0.100       2004\n    #> 4 David      21 Statistics         3.6    0.4         2003\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    # 示例4: 修改现有列 (例如，将 GPA 乘以 25 得到百分制)\n    students_data %>%\n      mutate(GPA_percent = GPA * 25) # 创建新列\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    #> # A tibble: 4 × 5\n    #>   Name      Age Major              GPA GPA_percent\n    #>   <chr>   <dbl> <chr>            <dbl>       <dbl>\n    #> 1 Alice      21 Statistics         3.8        95  \n    #> 2 Bob        22 Computer Science   3.5        87.5\n    #> 3 Charlie    20 Mathematics        3.9        97.5\n    #> 4 David      21 Statistics         3.6        90\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    # 示例5: 直接修改原列 (需谨慎)\n    students_data %>%\n      mutate(GPA = GPA * 25)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    #> # A tibble: 4 × 4\n    #>   Name      Age Major              GPA\n    #>   <chr>   <dbl> <chr>            <dbl>\n    #> 1 Alice      21 Statistics        95  \n    #> 2 Bob        22 Computer Science  87.5\n    #> 3 Charlie    20 Mathematics       97.5\n    #> 4 David      21 Statistics        90\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n-   **`arrange()`: 按列排序行**\n\n    -   默认升序排列。\n    -   使用 `desc()` 进行降序排列。\n    -   可以按多个列排序。\n\n\n\n\n    ::: {.cell layout-align=\"center\"}\n    \n    ```{.r .cell-code}\n    # 按年龄升序排序\n    students_data %>% arrange(Age)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    #> # A tibble: 4 × 4\n    #>   Name      Age Major              GPA\n    #>   <chr>   <dbl> <chr>            <dbl>\n    #> 1 Charlie    20 Mathematics        3.9\n    #> 2 Alice      21 Statistics         3.8\n    #> 3 David      21 Statistics         3.6\n    #> 4 Bob        22 Computer Science   3.5\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    # 按 GPA 降序排序\n    students_data %>% arrange(desc(GPA))\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    #> # A tibble: 4 × 4\n    #>   Name      Age Major              GPA\n    #>   <chr>   <dbl> <chr>            <dbl>\n    #> 1 Charlie    20 Mathematics        3.9\n    #> 2 Alice      21 Statistics         3.8\n    #> 3 David      21 Statistics         3.6\n    #> 4 Bob        22 Computer Science   3.5\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    # 先按专业升序，再按 GPA 降序\n    students_data %>% arrange(Major, desc(GPA))\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    #> # A tibble: 4 × 4\n    #>   Name      Age Major              GPA\n    #>   <chr>   <dbl> <chr>            <dbl>\n    #> 1 Bob        22 Computer Science   3.5\n    #> 2 Charlie    20 Mathematics        3.9\n    #> 3 Alice      21 Statistics         3.8\n    #> 4 David      21 Statistics         3.6\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n-   **`group_by()`: 按分类变量分组**\n\n    -   本身不改变数据外观，但会为后续操作（主要是 `summarise()`）添加分组信息。\n    -   后续操作将在每个分组内部独立进行。\n\n\n\n\n    ::: {.cell layout-align=\"center\"}\n    \n    ```{.r .cell-code}\n    # 按专业分组 (输出看起来没变，但内部结构变了)\n    students_data %>% group_by(Major)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    #> # A tibble: 4 × 4\n    #> # Groups:   Major [3]\n    #>   Name      Age Major              GPA\n    #>   <chr>   <dbl> <chr>            <dbl>\n    #> 1 Alice      21 Statistics         3.8\n    #> 2 Bob        22 Computer Science   3.5\n    #> 3 Charlie    20 Mathematics        3.9\n    #> 4 David      21 Statistics         3.6\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    # 按学生ID分组 exam_scores 数据\n    exam_scores %>% group_by(StudentID)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    #> # A tibble: 7 × 3\n    #> # Groups:   StudentID [3]\n    #>   StudentID Exam    Score\n    #>       <dbl> <chr>   <dbl>\n    #> 1       101 Midterm    85\n    #> 2       102 Midterm    90\n    #> 3       101 Final      88\n    #> 4       103 Midterm    75\n    #> 5       102 Final      92\n    #> 6       103 Final      80\n    #> 7       101 Quiz1      95\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n-   **`summarise()` (或 `summarize()`): 数据汇总**\n\n    -   通常与 `group_by()` 结合使用，对每个分组进行汇总计算。\n    -   创建包含汇总统计量的新数据框。\n    -   常用的汇总函数：`mean()`, `median()`, `sd()`, `var()`, `min()`, `max()`, `n()` (计算行数/观测数), `n_distinct()` (计算唯一值数量)。\n\n\n\n\n    ::: {.cell layout-align=\"center\"}\n    \n    ```{.r .cell-code}\n    # 计算所有学生的平均年龄和最高 GPA (没有 group_by)\n    students_data %>%\n      summarise(\n        Avg_Age = mean(Age),\n        Max_GPA = max(GPA)\n      )\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    #> # A tibble: 1 × 2\n    #>   Avg_Age Max_GPA\n    #>     <dbl>   <dbl>\n    #> 1      21     3.9\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    # 计算每个专业的学生人数和平均 GPA\n    students_data %>%\n      group_by(Major) %>%\n      summarise(\n        Num_Students = n(), # n() 计算当前分组的行数\n        Avg_GPA = mean(GPA, na.rm = TRUE) # 好习惯：处理可能的NA\n      )\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    #> # A tibble: 3 × 3\n    #>   Major            Num_Students Avg_GPA\n    #>   <chr>                   <int>   <dbl>\n    #> 1 Computer Science            1     3.5\n    #> 2 Mathematics                 1     3.9\n    #> 3 Statistics                  2     3.7\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    # 计算每个学生的考试次数和平均分\n    exam_scores %>%\n      group_by(StudentID) %>%\n      summarise(\n        Num_Exams = n(),\n        Avg_Score = mean(Score),\n        Min_Score = min(Score),\n        Max_Score = max(Score)\n      )\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    #> # A tibble: 3 × 5\n    #>   StudentID Num_Exams Avg_Score Min_Score Max_Score\n    #>       <dbl>     <int>     <dbl>     <dbl>     <dbl>\n    #> 1       101         3      89.3        85        95\n    #> 2       102         2      91          90        92\n    #> 3       103         2      77.5        75        80\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    # 计算每门考试的参加人数和最高分\n    exam_scores %>%\n      group_by(Exam) %>%\n      summarise(\n        Num_Participants = n_distinct(StudentID), # 统计不重复的学生ID数\n        Highest_Score = max(Score)\n      )\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    #> # A tibble: 3 × 3\n    #>   Exam    Num_Participants Highest_Score\n    #>   <chr>              <int>         <dbl>\n    #> 1 Final                  3            92\n    #> 2 Midterm                3            90\n    #> 3 Quiz1                  1            95\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n    ::: {.callout-tip title=\"`ungroup()`\"}\n    使用 `group_by()` 后，数据会保持分组状态。如果后续操作希望在整个数据集上进行，而不是分组进行，需要使用 `ungroup()` 取消分组。\n\n\n\n\n    ::: {.cell layout-align=\"center\"}\n    \n    ```{.r .cell-code}\n    students_data %>%\n      group_by(Major) %>%\n      mutate(Major_Avg_GPA = mean(GPA)) %>% # 在分组内计算平均GPA\n      ungroup() %>% # 取消分组\n      mutate(Overall_Avg_GPA = mean(GPA)) # 在全体数据上计算总平均GPA\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    #> # A tibble: 4 × 6\n    #>   Name      Age Major              GPA Major_Avg_GPA Overall_Avg_GPA\n    #>   <chr>   <dbl> <chr>            <dbl>         <dbl>           <dbl>\n    #> 1 Alice      21 Statistics         3.8           3.7             3.7\n    #> 2 Bob        22 Computer Science   3.5           3.5             3.7\n    #> 3 Charlie    20 Mathematics        3.9           3.9             3.7\n    #> 4 David      21 Statistics         3.6           3.7             3.7\n    ```\n    \n    \n    :::\n    :::\n\n\n\n    :::\n\n## 2. 整洁数据 (Tidy Data) 的理念\n\n\"整洁数据\" 是由 Hadley Wickham 提出的数据组织标准，旨在简化数据分析流程。遵循整洁数据原则的数据更易于使用 `tidyverse` 工具进行处理和可视化。\n\n-   **三条核心原则:**\n    1.  **每个变量构成一列 (Each variable forms a column)。**\n    2.  **每个观测构成一行 (Each observation forms a row)。**\n    3.  **每种类型的观测单元构成一个表格 (Each type of observational unit forms a table)。**\n-   **为何重要？**\n    -   `tidyverse` 中的函数（`dplyr`, `ggplot2` 等）都设计为处理整洁数据。\n    -   使数据结构标准化，便于理解和协作。\n    -   简化数据清理和转换步骤。\n-   **不整洁数据的常见形式:**\n    -   列名是变量值，而不是变量名 (例如，年份作为列名)。\n    -   一个单元格中存储了多个值。\n    -   变量同时存储在行和列中。\n\n## 3. `tidyr`: 让数据更整洁\n\n`tidyr` 包提供了将数据在\"宽\"格式和\"长\"格式之间转换的函数，帮助我们将数据整理成\"整洁\"的形式。\n\n-   **宽数据 (Wide Data):** 通常人类阅读更友好，但不利于计算。变量值可能作为列名。\n\n-   **长数据 (Long Data):** 通常更符合整洁数据原则，便于 `tidyverse` 处理。每个观测的关键信息都在行内，变量名在列中。\n\n-   **核心函数:**\n\n    -   `pivot_longer()`: 将**宽数据变长**。将多个列\"融合\"成键-值对的两列。\n    -   `pivot_wider()`: 将**长数据变宽**。根据键-值对将数据\"展开\"到多个列。\n\n-   **`pivot_longer()` 示例:** 假设我们有如下\"宽\"格式数据，记录了不同季度销售额：\n    \n\n\n\n    ::: {.cell layout-align=\"center\"}\n    \n    ```{.r .cell-code}\n    sales_wide <- tibble(\n      Product = c(\"A\", \"B\"),\n      Qtr1 = c(100, 150),\n      Qtr2 = c(110, 160),\n      Qtr3 = c(120, 170),\n      Qtr4 = c(130, 180)\n      )\n      \n      print(sales_wide)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    #> # A tibble: 2 × 5\n    #>   Product  Qtr1  Qtr2  Qtr3  Qtr4\n    #>   <chr>   <dbl> <dbl> <dbl> <dbl>\n    #> 1 A         100   110   120   130\n    #> 2 B         150   160   170   180\n    ```\n    \n    \n    :::\n    :::\n\n\n\n      \n    这里的列名 `Qtr1` 到 `Qtr4` 实际上是\"季度\"这个变量的值。我们希望将其转换为整洁的长格式：\n\n\n\n    ::: {.cell layout-align=\"center\"}\n    \n    ```{.r .cell-code}\n    sales_long <- sales_wide %>%\n      pivot_longer(\n        cols = Qtr1:Qtr4, # 指定哪些列需要被转换 (这里是 Qtr1 到 Qtr4) \n        names_to = \"Quarter\",  # 新列名，用于存储原来的列名 (Qtr1, Qtr2...)\n        values_to = \"Sales\"    # 新列名，用于存储原来的单元格值\n      )\n    \n    print(sales_long)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    #> # A tibble: 8 × 3\n    #>   Product Quarter Sales\n    #>   <chr>   <chr>   <dbl>\n    #> 1 A       Qtr1      100\n    #> 2 A       Qtr2      110\n    #> 3 A       Qtr3      120\n    #> 4 A       Qtr4      130\n    #> 5 B       Qtr1      150\n    #> 6 B       Qtr2      160\n    #> 7 B       Qtr3      170\n    #> 8 B       Qtr4      180\n    ```\n    \n    \n    :::\n    :::\n\n\n\n      \n      现在，每个观测（某个产品在某个季度的销售额）都独占一行，变量（产品、季度、销售额）各自成列。\n\n-   **`pivot_wider()` 示例:** 将刚才的长数据 `sales_long` 转换回宽数据： \n\n\n\n\n    ::: {.cell layout-align=\"center\"}\n    \n    ```{.r .cell-code}\n    sales_regained_wide <- sales_long %>%\n      pivot_wider(\n        names_from = Quarter, # 指定包含新列名的列 (Quarter)\n        values_from = Sales   # 指定包含新单元格值的列 (Sales)\n        )\n        \n    print(sales_regained_wide)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    #> # A tibble: 2 × 5\n    #>   Product  Qtr1  Qtr2  Qtr3  Qtr4\n    #>   <chr>   <dbl> <dbl> <dbl> <dbl>\n    #> 1 A         100   110   120   130\n    #> 2 B         150   160   170   180\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n## 4. 处理缺失值 (NA)\n\n缺失值 (NA, Not Available) 在真实数据中非常常见。`dplyr` 和 `tidyr` 以及 R 基础函数提供了处理它们的方法。\n\n-   **识别缺失值:** `is.na()` 函数返回一个逻辑向量，`TRUE` 表示对应位置是 NA。\n\n\n\n\n    ::: {.cell layout-align=\"center\"}\n    \n    ```{.r .cell-code}\n    x <- c(1, 2, NA, 4, NA)\n    is.na(x)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    #> [1] FALSE FALSE  TRUE FALSE  TRUE\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    # 在数据框中使用 (例如，检查 exam_scores 中是否有 NA)\n    is.na(exam_scores) # 返回一个与数据框同样大小的逻辑矩阵\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    #>      StudentID  Exam Score\n    #> [1,]     FALSE FALSE FALSE\n    #> [2,]     FALSE FALSE FALSE\n    #> [3,]     FALSE FALSE FALSE\n    #> [4,]     FALSE FALSE FALSE\n    #> [5,]     FALSE FALSE FALSE\n    #> [6,]     FALSE FALSE FALSE\n    #> [7,]     FALSE FALSE FALSE\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    any(is.na(exam_scores)) # 检查整个数据框是否有任何 NA\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    #> [1] FALSE\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    colSums(is.na(exam_scores)) # 计算每列的 NA 数量\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    #> StudentID      Exam     Score \n    #>         0         0         0\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n-   **处理策略:**\n\n    1.  **删除:**\n\n        -   `na.omit()` (基础 R): 删除**任何列**包含 NA 的**整行**。简单粗暴，可能丢失过多信息。\n        -   `drop_na()` (`tidyr`): 功能类似 `na.omit()`, 但可以指定只检查某些列的 NA。\n\n\n\n\n    ::: {.cell layout-align=\"center\"}\n    \n    ```{.r .cell-code}\n    scores_na_df <- tibble(ID = 1:6, Score = c(85, 92, NA, 88, 95, 72))\n    print(scores_na_df)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    #> # A tibble: 6 × 2\n    #>      ID Score\n    #>   <int> <dbl>\n    #> 1     1    85\n    #> 2     2    92\n    #> 3     3    NA\n    #> 4     4    88\n    #> 5     5    95\n    #> 6     6    72\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    na.omit(scores_na_df) # 删除包含 NA 的行\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    #> # A tibble: 5 × 2\n    #>      ID Score\n    #>   <int> <dbl>\n    #> 1     1    85\n    #> 2     2    92\n    #> 3     4    88\n    #> 4     5    95\n    #> 5     6    72\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    library(tidyr)\n    scores_na_df %>% drop_na() # 同上\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    #> # A tibble: 5 × 2\n    #>      ID Score\n    #>   <int> <dbl>\n    #> 1     1    85\n    #> 2     2    92\n    #> 3     4    88\n    #> 4     5    95\n    #> 5     6    72\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    # 假设有另一列，我们只想删除 Score 为 NA 的行\n    scores_na_df2 <- tibble(\n      ID = 1:6,\n      Score = c(85, 92, NA, 88, 95, 72),\n      Group = c(\"A\", \"B\", \"A\", NA, \"B\", \"A\")\n      )\n    print(scores_na_df2)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    #> # A tibble: 6 × 3\n    #>      ID Score Group\n    #>   <int> <dbl> <chr>\n    #> 1     1    85 A    \n    #> 2     2    92 B    \n    #> 3     3    NA A    \n    #> 4     4    88 <NA> \n    #> 5     5    95 B    \n    #> 6     6    72 A\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    scores_na_df2 %>% drop_na(Score) # 只检查 Score 列的 NA\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    #> # A tibble: 5 × 3\n    #>      ID Score Group\n    #>   <int> <dbl> <chr>\n    #> 1     1    85 A    \n    #> 2     2    92 B    \n    #> 3     4    88 <NA> \n    #> 4     5    95 B    \n    #> 5     6    72 A\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n    2.  **填充/插补 (Imputation):** 用某个值（如均值、中位数、众数或模型预测值）替换 NA。这更复杂，需要根据具体情况选择合适的方法（后续课程可能涉及）。\n\n    -   `replace_na()` (`tidyr`): 用指定值替换 NA。\n\n\n\n\n    ::: {.cell layout-align=\"center\"}\n    \n    ```{.r .cell-code}\n    scores_na_df %>%\n      mutate(Score_filled = replace_na(Score, mean(Score, na.rm = TRUE))) # 用均值填充\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    #> # A tibble: 6 × 3\n    #>      ID Score Score_filled\n    #>   <int> <dbl>        <dbl>\n    #> 1     1    85         85  \n    #> 2     2    92         92  \n    #> 3     3    NA         86.4\n    #> 4     4    88         88  \n    #> 5     5    95         95  \n    #> 6     6    72         72\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n    3.  **在计算中忽略:** 许多函数（如 `mean()`, `sum()`, `sd()` 等）有 `na.rm = TRUE` 参数。 \n    \n\n\n\n    ::: {.cell layout-align=\"center\"}\n    \n    ```{.r .cell-code}\n    mean(scores_na_df$Score) # NA\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    #> [1] NA\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    mean(scores_na_df$Score, na.rm = TRUE) # 正确计算\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    #> [1] 86.4\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n::: {.callout-warning title=\"处理 NA 的重要性\"}\n不恰当处理 NA 会导致分析结果偏差甚至错误。选择哪种策略取决于数据的性质、缺失的原因以及分析的目标。删除是最简单的方法，但只有在 NA 占比很小或确定该观测无效时才推荐。\n:::\n\n## 5. 管道 (`%>%`) 连接多步操作\n\n管道使得复杂的数据处理流程清晰易读。\n\n-   **示例：** 从 `exam_scores` 数据中，找出每个学生（StudentID）的最高分（Max_Score），并按最高分降序排列，最后只显示 StudentID 和 Max_Score。\n\n\n\n    ::: {.cell layout-align=\"center\"}\n    \n    ```{.r .cell-code}\n    exam_scores %>%\n      group_by(StudentID) %>% # 按学生分组\n      summarise(Max_Score = max(Score)) %>% # 计算每个学生的最高分\n      arrange(desc(Max_Score)) %>% # 按最高分降序排列\n      ungroup() # 最好取消分组（虽然这里影响不大）\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    #> # A tibble: 3 × 2\n    #>   StudentID Max_Score\n    #>       <dbl>     <dbl>\n    #> 1       101        95\n    #> 2       102        92\n    #> 3       103        80\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n-   **对比不使用管道的代码：**\n\n\n\n    ::: {.cell layout-align=\"center\"}\n    \n    ```{.r .cell-code}\n    grouped_data <- group_by(exam_scores, StudentID)\n    summary_data <- summarise(grouped_data, Max_Score = max(Score))\n    arranged_data <- arrange(summary_data, desc(Max_Score))\n    ungroup(arranged_data)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    #> # A tibble: 3 × 2\n    #>   StudentID Max_Score\n    #>       <dbl>     <dbl>\n    #> 1       101        95\n    #> 2       102        92\n    #> 3       103        80\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n管道显然更简洁、更符合思维流程。\n\n## 6. 项目相关与本周总结\n\n-   **项目任务:**\n    -   应用本周学到的 `dplyr` 动词（`mutate`, `arrange`, `group_by`, `summarise`）对你的项目数据进行初步的探索性分析。例如，计算分组统计量，创建新变量，按特定条件排序。\n    -   检查你的项目数据是否符合\"整洁数据\"原则。如果不符合，思考如何使用 `pivot_longer` 或 `pivot_wider` 进行转换（如果适用）。\n    -   检查项目数据中的缺失值 (`is.na()`, `colSums(is.na())`)。思考初步的处理策略（暂时可以先记录下来，不一定立即处理）。\n-   **本周回顾:** 我们掌握了 `dplyr` 的核心转换函数和 `tidyr` 的长宽格式转换，理解了整洁数据的重要性，并学习了处理缺失值的基本方法。通过管道，我们可以将这些操作流畅地组合起来，高效地完成数据整形任务。\n\n**下周预告:** 数据准备就绪，是时候让数据\"说话\"了！我们将学习强大的可视化工具 `ggplot2`，探索如何通过图形发现数据中的模式和洞见，并初步接触推断统计的思想。",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}